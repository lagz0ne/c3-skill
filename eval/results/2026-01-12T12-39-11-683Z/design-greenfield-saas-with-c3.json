{
  "name": "Design greenfield SaaS with C3",
  "pass": true,
  "score": 100,
  "duration": 424713,
  "trace": [
    {
      "timestamp": "2026-01-12T12:26:56.626Z",
      "event": "PreToolUse",
      "tool": "Skill",
      "input": {
        "skill": "c3-skill:onboard"
      }
    },
    {
      "timestamp": "2026-01-12T12:26:56.833Z",
      "event": "PostToolUse",
      "tool": "Skill",
      "input": {
        "skill": "c3-skill:onboard"
      },
      "result": {
        "success": true,
        "commandName": "c3-skill:onboard",
        "allowedTools": [
          "Bash(rm:*)",
          "Bash(test:*)",
          "Bash(PROJECT=*)",
          "Read",
          "Glob",
          "Grep",
          "Write",
          "Edit",
          "AskUserQuestion",
          "Skill"
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:27:02.485Z",
      "event": "PreToolUse",
      "tool": "Bash",
      "input": {
        "command": "mkdir -p .c3/adrs .c3/refs",
        "description": "Create C3 directory structure"
      }
    },
    {
      "timestamp": "2026-01-12T12:27:02.515Z",
      "event": "PostToolUse",
      "tool": "Bash",
      "input": {
        "command": "mkdir -p .c3/adrs .c3/refs",
        "description": "Create C3 directory structure"
      },
      "result": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false
      }
    },
    {
      "timestamp": "2026-01-12T12:27:06.570Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "in_progress",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "pending",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:27:06.589Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "in_progress",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "pending",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "in_progress",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "pending",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:27:20.663Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/Users/user/DevProjects/taskflow/.c3/c3-context.md",
        "content": "# C3 Context: TaskFlow\n\n> Task management SaaS for small teams with real-time collaboration\n\n## System Boundary\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              TaskFlow System                                 │\n│                                                                             │\n│  Multi-tenant task management platform with real-time collaboration        │\n│  for small teams. Modular monolith architecture designed for future        │\n│  decomposition into microservices.                                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n          │                    │                    │\n          ▼                    ▼                    ▼\n    ┌──────────┐        ┌──────────────┐     ┌─────────────┐\n    │  Team    │        │   Google     │     │   Future    │\n    │  Members │        │   OAuth      │     │   Mobile    │\n    │  (Users) │        │   Provider   │     │   Apps      │\n    └──────────┘        └──────────────┘     └─────────────┘\n```\n\n## External Actors\n\n| Actor | Type | Description |\n|-------|------|-------------|\n| Team Members | User | Primary users: create tasks, manage boards, collaborate in real-time |\n| Google OAuth | External System | Authentication provider for user identity |\n| Future Mobile Apps | External System | iOS/Android apps consuming the REST API |\n\n## System Purpose\n\nTaskFlow enables small teams (5-50 members) to:\n- Organize work in **workspaces** (multi-tenant isolation)\n- Create and manage **task boards** (Kanban-style)\n- Collaborate in **real-time** (live updates, presence)\n- Track task **assignments, due dates, and progress**\n\n## Key Quality Attributes\n\n| Attribute | Priority | Target |\n|-----------|----------|--------|\n| Real-time sync | High | <500ms latency for board updates |\n| Multi-tenancy | High | Complete data isolation between teams |\n| API-first | High | REST API suitable for mobile consumption |\n| Scalability | Medium | Support 100+ concurrent users per workspace |\n| Availability | Medium | 99.5% uptime |\n\n## Constraints\n\n- **Technology**: Node.js/TypeScript, React, PostgreSQL, Redis\n- **Architecture**: Modular monolith (single deployment, modular boundaries)\n- **Authentication**: Google OAuth only (initially)\n- **Deployment**: Single region (multi-region deferred)\n\n---\n\n**Next**: See [c3-containers.md](./c3-containers.md) for deployable units\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:27:20.663Z",
      "event": "Blocked",
      "tool": "Write",
      "input": {
        "file_path": "/Users/user/DevProjects/taskflow/.c3/c3-context.md",
        "content": "# C3 Context: TaskFlow\n\n> Task management SaaS for small teams with real-time collaboration\n\n## System Boundary\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              TaskFlow System                                 │\n│                                                                             │\n│  Multi-tenant task management platform with real-time collaboration        │\n│  for small teams. Modular monolith architecture designed for future        │\n│  decomposition into microservices.                                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n          │                    │                    │\n          ▼                    ▼                    ▼\n    ┌──────────┐        ┌──────────────┐     ┌─────────────┐\n    │  Team    │        │   Google     │     │   Future    │\n    │  Members │        │   OAuth      │     │   Mobile    │\n    │  (Users) │        │   Provider   │     │   Apps      │\n    └──────────┘        └──────────────┘     └─────────────┘\n```\n\n## External Actors\n\n| Actor | Type | Description |\n|-------|------|-------------|\n| Team Members | User | Primary users: create tasks, manage boards, collaborate in real-time |\n| Google OAuth | External System | Authentication provider for user identity |\n| Future Mobile Apps | External System | iOS/Android apps consuming the REST API |\n\n## System Purpose\n\nTaskFlow enables small teams (5-50 members) to:\n- Organize work in **workspaces** (multi-tenant isolation)\n- Create and manage **task boards** (Kanban-style)\n- Collaborate in **real-time** (live updates, presence)\n- Track task **assignments, due dates, and progress**\n\n## Key Quality Attributes\n\n| Attribute | Priority | Target |\n|-----------|----------|--------|\n| Real-time sync | High | <500ms latency for board updates |\n| Multi-tenancy | High | Complete data isolation between teams |\n| API-first | High | REST API suitable for mobile consumption |\n| Scalability | Medium | Support 100+ concurrent users per workspace |\n| Availability | Medium | 99.5% uptime |\n\n## Constraints\n\n- **Technology**: Node.js/TypeScript, React, PostgreSQL, Redis\n- **Architecture**: Modular monolith (single deployment, modular boundaries)\n- **Authentication**: Google OAuth only (initially)\n- **Deployment**: Single region (multi-region deferred)\n\n---\n\n**Next**: See [c3-containers.md](./c3-containers.md) for deployable units\n"
      },
      "blocked": true,
      "reason": "Path outside sandbox: /Users/user/DevProjects/taskflow/.c3/c3-context.md"
    },
    {
      "timestamp": "2026-01-12T12:27:23.302Z",
      "event": "PreToolUse",
      "tool": "Bash",
      "input": {
        "command": "pwd",
        "description": "Check current working directory"
      }
    },
    {
      "timestamp": "2026-01-12T12:27:23.331Z",
      "event": "PostToolUse",
      "tool": "Bash",
      "input": {
        "command": "pwd",
        "description": "Check current working directory"
      },
      "result": {
        "stdout": "/tmp/tmp.gWJkWnuCWD",
        "stderr": "",
        "interrupted": false,
        "isImage": false
      }
    },
    {
      "timestamp": "2026-01-12T12:27:27.657Z",
      "event": "PreToolUse",
      "tool": "Bash",
      "input": {
        "command": "mkdir -p .c3/adrs .c3/refs && ls -la",
        "description": "Create C3 directory structure in current directory"
      }
    },
    {
      "timestamp": "2026-01-12T12:27:27.685Z",
      "event": "PostToolUse",
      "tool": "Bash",
      "input": {
        "command": "mkdir -p .c3/adrs .c3/refs && ls -la",
        "description": "Create C3 directory structure in current directory"
      },
      "result": {
        "stdout": "",
        "stderr": "",
        "interrupted": false,
        "isImage": false
      }
    },
    {
      "timestamp": "2026-01-12T12:27:35.062Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-context.md",
        "content": "# C3 Context: TaskFlow\n\n> Task management SaaS for small teams with real-time collaboration\n\n## System Boundary\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              TaskFlow System                                 │\n│                                                                             │\n│  Multi-tenant task management platform with real-time collaboration        │\n│  for small teams. Modular monolith architecture designed for future        │\n│  decomposition into microservices.                                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n          │                    │                    │\n          ▼                    ▼                    ▼\n    ┌──────────┐        ┌──────────────┐     ┌─────────────┐\n    │  Team    │        │   Google     │     │   Future    │\n    │  Members │        │   OAuth      │     │   Mobile    │\n    │  (Users) │        │   Provider   │     │   Apps      │\n    └──────────┘        └──────────────┘     └─────────────┘\n```\n\n## External Actors\n\n| Actor | Type | Description |\n|-------|------|-------------|\n| Team Members | User | Primary users: create tasks, manage boards, collaborate in real-time |\n| Google OAuth | External System | Authentication provider for user identity |\n| Future Mobile Apps | External System | iOS/Android apps consuming the REST API |\n\n## System Purpose\n\nTaskFlow enables small teams (5-50 members) to:\n- Organize work in **workspaces** (multi-tenant isolation)\n- Create and manage **task boards** (Kanban-style)\n- Collaborate in **real-time** (live updates, presence)\n- Track task **assignments, due dates, and progress**\n\n## Key Quality Attributes\n\n| Attribute | Priority | Target |\n|-----------|----------|--------|\n| Real-time sync | High | <500ms latency for board updates |\n| Multi-tenancy | High | Complete data isolation between teams |\n| API-first | High | REST API suitable for mobile consumption |\n| Scalability | Medium | Support 100+ concurrent users per workspace |\n| Availability | Medium | 99.5% uptime |\n\n## Constraints\n\n- **Technology**: Node.js/TypeScript, React, PostgreSQL, Redis\n- **Architecture**: Modular monolith (single deployment, modular boundaries)\n- **Authentication**: Google OAuth only (initially)\n- **Deployment**: Single region (multi-region deferred)\n\n---\n\n**Next**: See [c3-containers.md](./c3-containers.md) for deployable units\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:27:35.087Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-context.md",
        "content": "# C3 Context: TaskFlow\n\n> Task management SaaS for small teams with real-time collaboration\n\n## System Boundary\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              TaskFlow System                                 │\n│                                                                             │\n│  Multi-tenant task management platform with real-time collaboration        │\n│  for small teams. Modular monolith architecture designed for future        │\n│  decomposition into microservices.                                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n          │                    │                    │\n          ▼                    ▼                    ▼\n    ┌──────────┐        ┌──────────────┐     ┌─────────────┐\n    │  Team    │        │   Google     │     │   Future    │\n    │  Members │        │   OAuth      │     │   Mobile    │\n    │  (Users) │        │   Provider   │     │   Apps      │\n    └──────────┘        └──────────────┘     └─────────────┘\n```\n\n## External Actors\n\n| Actor | Type | Description |\n|-------|------|-------------|\n| Team Members | User | Primary users: create tasks, manage boards, collaborate in real-time |\n| Google OAuth | External System | Authentication provider for user identity |\n| Future Mobile Apps | External System | iOS/Android apps consuming the REST API |\n\n## System Purpose\n\nTaskFlow enables small teams (5-50 members) to:\n- Organize work in **workspaces** (multi-tenant isolation)\n- Create and manage **task boards** (Kanban-style)\n- Collaborate in **real-time** (live updates, presence)\n- Track task **assignments, due dates, and progress**\n\n## Key Quality Attributes\n\n| Attribute | Priority | Target |\n|-----------|----------|--------|\n| Real-time sync | High | <500ms latency for board updates |\n| Multi-tenancy | High | Complete data isolation between teams |\n| API-first | High | REST API suitable for mobile consumption |\n| Scalability | Medium | Support 100+ concurrent users per workspace |\n| Availability | Medium | 99.5% uptime |\n\n## Constraints\n\n- **Technology**: Node.js/TypeScript, React, PostgreSQL, Redis\n- **Architecture**: Modular monolith (single deployment, modular boundaries)\n- **Authentication**: Google OAuth only (initially)\n- **Deployment**: Single region (multi-region deferred)\n\n---\n\n**Next**: See [c3-containers.md](./c3-containers.md) for deployable units\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/c3-context.md",
        "content": "# C3 Context: TaskFlow\n\n> Task management SaaS for small teams with real-time collaboration\n\n## System Boundary\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              TaskFlow System                                 │\n│                                                                             │\n│  Multi-tenant task management platform with real-time collaboration        │\n│  for small teams. Modular monolith architecture designed for future        │\n│  decomposition into microservices.                                          │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n          │                    │                    │\n          ▼                    ▼                    ▼\n    ┌──────────┐        ┌──────────────┐     ┌─────────────┐\n    │  Team    │        │   Google     │     │   Future    │\n    │  Members │        │   OAuth      │     │   Mobile    │\n    │  (Users) │        │   Provider   │     │   Apps      │\n    └──────────┘        └──────────────┘     └─────────────┘\n```\n\n## External Actors\n\n| Actor | Type | Description |\n|-------|------|-------------|\n| Team Members | User | Primary users: create tasks, manage boards, collaborate in real-time |\n| Google OAuth | External System | Authentication provider for user identity |\n| Future Mobile Apps | External System | iOS/Android apps consuming the REST API |\n\n## System Purpose\n\nTaskFlow enables small teams (5-50 members) to:\n- Organize work in **workspaces** (multi-tenant isolation)\n- Create and manage **task boards** (Kanban-style)\n- Collaborate in **real-time** (live updates, presence)\n- Track task **assignments, due dates, and progress**\n\n## Key Quality Attributes\n\n| Attribute | Priority | Target |\n|-----------|----------|--------|\n| Real-time sync | High | <500ms latency for board updates |\n| Multi-tenancy | High | Complete data isolation between teams |\n| API-first | High | REST API suitable for mobile consumption |\n| Scalability | Medium | Support 100+ concurrent users per workspace |\n| Availability | Medium | 99.5% uptime |\n\n## Constraints\n\n- **Technology**: Node.js/TypeScript, React, PostgreSQL, Redis\n- **Architecture**: Modular monolith (single deployment, modular boundaries)\n- **Authentication**: Google OAuth only (initially)\n- **Deployment**: Single region (multi-region deferred)\n\n---\n\n**Next**: See [c3-containers.md](./c3-containers.md) for deployable units\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:27:39.950Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "in_progress",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:27:39.958Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "in_progress",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "in_progress",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "pending",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "in_progress",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:28:06.033Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-containers.md",
        "content": "# C3 Containers: TaskFlow\n\n> Deployable units and their interactions\n\n## Container Diagram\n\n```\n                                    ┌─────────────────┐\n                                    │   Team Members  │\n                                    │     (Users)     │\n                                    └────────┬────────┘\n                                             │\n                        ┌────────────────────┼────────────────────┐\n                        │ HTTPS              │ WSS                │\n                        ▼                    ▼                    │\n               ┌─────────────────┐  ┌─────────────────┐          │\n               │   Web App SPA   │  │   WebSocket     │          │\n               │   [c3-0]        │  │   Connection    │          │\n               │                 │  │                 │          │\n               │ React 18        │  │ Real-time       │          │\n               │ TypeScript      │  │ collaboration   │          │\n               │ Vite            │  │                 │          │\n               └────────┬────────┘  └────────┬────────┘          │\n                        │                    │                    │\n                        │ REST API           │ WebSocket          │\n                        ▼                    ▼                    │\n               ┌─────────────────────────────────────────┐       │\n               │           API Server [c3-1]             │       │\n               │                                         │       │\n               │  Node.js / Express / TypeScript         │       │\n               │  Modular Monolith Architecture          │       │\n               │                                         │       │\n               │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │       │\n               │  │  Auth   │ │  Tasks  │ │  Real-  │   │       │\n               │  │ Module  │ │ Module  │ │  time   │   │       │\n               │  └─────────┘ └─────────┘ └─────────┘   │       │\n               └──────┬──────────────┬──────────┬───────┘       │\n                      │              │          │                │\n         ┌────────────┘              │          └────────┐       │\n         │                           │                   │       │\n         ▼                           ▼                   ▼       │\n┌─────────────────┐       ┌─────────────────┐   ┌─────────────┐ │\n│   PostgreSQL    │       │     Redis       │   │   Google    │ │\n│   [c3-2]        │       │     [c3-3]      │   │   OAuth     │◀┘\n│                 │       │                 │   │   [ext]     │\n│ Primary data    │       │ Cache layer     │   │             │\n│ store           │       │ Pub/Sub for     │   │ Identity    │\n│                 │       │ real-time       │   │ provider    │\n└─────────────────┘       └─────────────────┘   └─────────────┘\n```\n\n## Container Details\n\n### c3-0: Web Application (SPA)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | React 18, TypeScript, Vite |\n| Purpose | User interface for task management |\n| Deployment | Static hosting (CDN) |\n| Communication | REST API calls, WebSocket connection |\n\n**Key Responsibilities:**\n- Render task boards and workspaces\n- Handle user interactions\n- Maintain real-time sync via WebSocket\n- Optimistic updates for responsiveness\n\n---\n\n### c3-1: API Server (Modular Monolith)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Node.js 20+, Express, TypeScript |\n| Purpose | Business logic, API endpoints, WebSocket server |\n| Deployment | Container (Docker) |\n| Communication | HTTP REST, WebSocket, DB connections |\n\n**Key Responsibilities:**\n- Expose REST API for CRUD operations\n- Handle WebSocket connections for real-time\n- Enforce multi-tenant data isolation\n- Orchestrate business workflows\n\n**Module Boundaries (see components):**\n- `auth` - Authentication & authorization\n- `workspace` - Team/workspace management\n- `board` - Task board operations\n- `task` - Task CRUD and assignments\n- `realtime` - WebSocket & presence\n\n---\n\n### c3-2: PostgreSQL Database\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | PostgreSQL 15+ |\n| Purpose | Primary persistent data store |\n| Deployment | Managed service (AWS RDS, Supabase, etc.) |\n\n**Key Responsibilities:**\n- Store all business data (users, workspaces, boards, tasks)\n- Enforce data integrity via constraints\n- Row-level security for multi-tenancy\n- Support complex queries and reporting\n\n---\n\n### c3-3: Redis\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Redis 7+ |\n| Purpose | Caching, session store, pub/sub |\n| Deployment | Managed service (AWS ElastiCache, Upstash, etc.) |\n\n**Key Responsibilities:**\n- Cache frequently accessed data\n- Store user sessions\n- Pub/Sub for real-time broadcast across server instances\n- Rate limiting\n\n---\n\n## External Systems\n\n### Google OAuth Provider\n\n| Attribute | Value |\n|-----------|-------|\n| Type | External identity provider |\n| Protocol | OAuth 2.0 / OpenID Connect |\n| Purpose | User authentication |\n\n---\n\n## Communication Patterns\n\n| From | To | Protocol | Purpose |\n|------|----|----------|---------|\n| Web App | API Server | HTTPS REST | CRUD operations |\n| Web App | API Server | WSS | Real-time updates |\n| API Server | PostgreSQL | TCP/TLS | Data persistence |\n| API Server | Redis | TCP | Cache, pub/sub |\n| API Server | Google OAuth | HTTPS | Token verification |\n\n---\n\n**Next**: See [c3-components.md](./c3-components.md) for internal structure\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:28:06.046Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-containers.md",
        "content": "# C3 Containers: TaskFlow\n\n> Deployable units and their interactions\n\n## Container Diagram\n\n```\n                                    ┌─────────────────┐\n                                    │   Team Members  │\n                                    │     (Users)     │\n                                    └────────┬────────┘\n                                             │\n                        ┌────────────────────┼────────────────────┐\n                        │ HTTPS              │ WSS                │\n                        ▼                    ▼                    │\n               ┌─────────────────┐  ┌─────────────────┐          │\n               │   Web App SPA   │  │   WebSocket     │          │\n               │   [c3-0]        │  │   Connection    │          │\n               │                 │  │                 │          │\n               │ React 18        │  │ Real-time       │          │\n               │ TypeScript      │  │ collaboration   │          │\n               │ Vite            │  │                 │          │\n               └────────┬────────┘  └────────┬────────┘          │\n                        │                    │                    │\n                        │ REST API           │ WebSocket          │\n                        ▼                    ▼                    │\n               ┌─────────────────────────────────────────┐       │\n               │           API Server [c3-1]             │       │\n               │                                         │       │\n               │  Node.js / Express / TypeScript         │       │\n               │  Modular Monolith Architecture          │       │\n               │                                         │       │\n               │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │       │\n               │  │  Auth   │ │  Tasks  │ │  Real-  │   │       │\n               │  │ Module  │ │ Module  │ │  time   │   │       │\n               │  └─────────┘ └─────────┘ └─────────┘   │       │\n               └──────┬──────────────┬──────────┬───────┘       │\n                      │              │          │                │\n         ┌────────────┘              │          └────────┐       │\n         │                           │                   │       │\n         ▼                           ▼                   ▼       │\n┌─────────────────┐       ┌─────────────────┐   ┌─────────────┐ │\n│   PostgreSQL    │       │     Redis       │   │   Google    │ │\n│   [c3-2]        │       │     [c3-3]      │   │   OAuth     │◀┘\n│                 │       │                 │   │   [ext]     │\n│ Primary data    │       │ Cache layer     │   │             │\n│ store           │       │ Pub/Sub for     │   │ Identity    │\n│                 │       │ real-time       │   │ provider    │\n└─────────────────┘       └─────────────────┘   └─────────────┘\n```\n\n## Container Details\n\n### c3-0: Web Application (SPA)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | React 18, TypeScript, Vite |\n| Purpose | User interface for task management |\n| Deployment | Static hosting (CDN) |\n| Communication | REST API calls, WebSocket connection |\n\n**Key Responsibilities:**\n- Render task boards and workspaces\n- Handle user interactions\n- Maintain real-time sync via WebSocket\n- Optimistic updates for responsiveness\n\n---\n\n### c3-1: API Server (Modular Monolith)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Node.js 20+, Express, TypeScript |\n| Purpose | Business logic, API endpoints, WebSocket server |\n| Deployment | Container (Docker) |\n| Communication | HTTP REST, WebSocket, DB connections |\n\n**Key Responsibilities:**\n- Expose REST API for CRUD operations\n- Handle WebSocket connections for real-time\n- Enforce multi-tenant data isolation\n- Orchestrate business workflows\n\n**Module Boundaries (see components):**\n- `auth` - Authentication & authorization\n- `workspace` - Team/workspace management\n- `board` - Task board operations\n- `task` - Task CRUD and assignments\n- `realtime` - WebSocket & presence\n\n---\n\n### c3-2: PostgreSQL Database\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | PostgreSQL 15+ |\n| Purpose | Primary persistent data store |\n| Deployment | Managed service (AWS RDS, Supabase, etc.) |\n\n**Key Responsibilities:**\n- Store all business data (users, workspaces, boards, tasks)\n- Enforce data integrity via constraints\n- Row-level security for multi-tenancy\n- Support complex queries and reporting\n\n---\n\n### c3-3: Redis\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Redis 7+ |\n| Purpose | Caching, session store, pub/sub |\n| Deployment | Managed service (AWS ElastiCache, Upstash, etc.) |\n\n**Key Responsibilities:**\n- Cache frequently accessed data\n- Store user sessions\n- Pub/Sub for real-time broadcast across server instances\n- Rate limiting\n\n---\n\n## External Systems\n\n### Google OAuth Provider\n\n| Attribute | Value |\n|-----------|-------|\n| Type | External identity provider |\n| Protocol | OAuth 2.0 / OpenID Connect |\n| Purpose | User authentication |\n\n---\n\n## Communication Patterns\n\n| From | To | Protocol | Purpose |\n|------|----|----------|---------|\n| Web App | API Server | HTTPS REST | CRUD operations |\n| Web App | API Server | WSS | Real-time updates |\n| API Server | PostgreSQL | TCP/TLS | Data persistence |\n| API Server | Redis | TCP | Cache, pub/sub |\n| API Server | Google OAuth | HTTPS | Token verification |\n\n---\n\n**Next**: See [c3-components.md](./c3-components.md) for internal structure\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/c3-containers.md",
        "content": "# C3 Containers: TaskFlow\n\n> Deployable units and their interactions\n\n## Container Diagram\n\n```\n                                    ┌─────────────────┐\n                                    │   Team Members  │\n                                    │     (Users)     │\n                                    └────────┬────────┘\n                                             │\n                        ┌────────────────────┼────────────────────┐\n                        │ HTTPS              │ WSS                │\n                        ▼                    ▼                    │\n               ┌─────────────────┐  ┌─────────────────┐          │\n               │   Web App SPA   │  │   WebSocket     │          │\n               │   [c3-0]        │  │   Connection    │          │\n               │                 │  │                 │          │\n               │ React 18        │  │ Real-time       │          │\n               │ TypeScript      │  │ collaboration   │          │\n               │ Vite            │  │                 │          │\n               └────────┬────────┘  └────────┬────────┘          │\n                        │                    │                    │\n                        │ REST API           │ WebSocket          │\n                        ▼                    ▼                    │\n               ┌─────────────────────────────────────────┐       │\n               │           API Server [c3-1]             │       │\n               │                                         │       │\n               │  Node.js / Express / TypeScript         │       │\n               │  Modular Monolith Architecture          │       │\n               │                                         │       │\n               │  ┌─────────┐ ┌─────────┐ ┌─────────┐   │       │\n               │  │  Auth   │ │  Tasks  │ │  Real-  │   │       │\n               │  │ Module  │ │ Module  │ │  time   │   │       │\n               │  └─────────┘ └─────────┘ └─────────┘   │       │\n               └──────┬──────────────┬──────────┬───────┘       │\n                      │              │          │                │\n         ┌────────────┘              │          └────────┐       │\n         │                           │                   │       │\n         ▼                           ▼                   ▼       │\n┌─────────────────┐       ┌─────────────────┐   ┌─────────────┐ │\n│   PostgreSQL    │       │     Redis       │   │   Google    │ │\n│   [c3-2]        │       │     [c3-3]      │   │   OAuth     │◀┘\n│                 │       │                 │   │   [ext]     │\n│ Primary data    │       │ Cache layer     │   │             │\n│ store           │       │ Pub/Sub for     │   │ Identity    │\n│                 │       │ real-time       │   │ provider    │\n└─────────────────┘       └─────────────────┘   └─────────────┘\n```\n\n## Container Details\n\n### c3-0: Web Application (SPA)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | React 18, TypeScript, Vite |\n| Purpose | User interface for task management |\n| Deployment | Static hosting (CDN) |\n| Communication | REST API calls, WebSocket connection |\n\n**Key Responsibilities:**\n- Render task boards and workspaces\n- Handle user interactions\n- Maintain real-time sync via WebSocket\n- Optimistic updates for responsiveness\n\n---\n\n### c3-1: API Server (Modular Monolith)\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Node.js 20+, Express, TypeScript |\n| Purpose | Business logic, API endpoints, WebSocket server |\n| Deployment | Container (Docker) |\n| Communication | HTTP REST, WebSocket, DB connections |\n\n**Key Responsibilities:**\n- Expose REST API for CRUD operations\n- Handle WebSocket connections for real-time\n- Enforce multi-tenant data isolation\n- Orchestrate business workflows\n\n**Module Boundaries (see components):**\n- `auth` - Authentication & authorization\n- `workspace` - Team/workspace management\n- `board` - Task board operations\n- `task` - Task CRUD and assignments\n- `realtime` - WebSocket & presence\n\n---\n\n### c3-2: PostgreSQL Database\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | PostgreSQL 15+ |\n| Purpose | Primary persistent data store |\n| Deployment | Managed service (AWS RDS, Supabase, etc.) |\n\n**Key Responsibilities:**\n- Store all business data (users, workspaces, boards, tasks)\n- Enforce data integrity via constraints\n- Row-level security for multi-tenancy\n- Support complex queries and reporting\n\n---\n\n### c3-3: Redis\n\n| Attribute | Value |\n|-----------|-------|\n| Technology | Redis 7+ |\n| Purpose | Caching, session store, pub/sub |\n| Deployment | Managed service (AWS ElastiCache, Upstash, etc.) |\n\n**Key Responsibilities:**\n- Cache frequently accessed data\n- Store user sessions\n- Pub/Sub for real-time broadcast across server instances\n- Rate limiting\n\n---\n\n## External Systems\n\n### Google OAuth Provider\n\n| Attribute | Value |\n|-----------|-------|\n| Type | External identity provider |\n| Protocol | OAuth 2.0 / OpenID Connect |\n| Purpose | User authentication |\n\n---\n\n## Communication Patterns\n\n| From | To | Protocol | Purpose |\n|------|----|----------|---------|\n| Web App | API Server | HTTPS REST | CRUD operations |\n| Web App | API Server | WSS | Real-time updates |\n| API Server | PostgreSQL | TCP/TLS | Data persistence |\n| API Server | Redis | TCP | Cache, pub/sub |\n| API Server | Google OAuth | HTTPS | Token verification |\n\n---\n\n**Next**: See [c3-components.md](./c3-components.md) for internal structure\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:28:10.802Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "in_progress",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:28:10.810Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "in_progress",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "in_progress",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "pending",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "in_progress",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:29:07.374Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-components.md",
        "content": "# C3 Components: TaskFlow\n\n> Internal structure of containers, organized by Foundation and Feature modules\n\n## Component Overview\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         API Server [c3-1]                                   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                     FOUNDATION LAYER                                 │   │\n│  │  Cross-cutting concerns shared by all feature modules                │   │\n│  │                                                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │\n│  │  │  HTTP    │ │  Auth    │ │  DB      │ │  Cache   │ │  Events  │  │   │\n│  │  │  Core    │ │  Guard   │ │  Client  │ │  Layer   │ │  Bus     │  │   │\n│  │  │  c3-1.0  │ │  c3-1.1  │ │  c3-1.2  │ │  c3-1.3  │ │  c3-1.4  │  │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURE LAYER                                   │   │\n│  │  Domain modules with clear boundaries (future microservices)         │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Workspace  │ │    Board     │ │    Task      │                 │   │\n│  │  │    Module    │ │    Module    │ │    Module    │                 │   │\n│  │  │    c3-1.5    │ │    c3-1.6    │ │    c3-1.7    │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐                                  │   │\n│  │  │   Realtime   │ │    User      │                                  │   │\n│  │  │    Module    │ │    Module    │                                  │   │\n│  │  │    c3-1.8    │ │    c3-1.9    │                                  │   │\n│  │  └──────────────┘ └──────────────┘                                  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Foundation Components\n\n### c3-1.0: HTTP Core\n\n**Purpose:** Express application setup, middleware pipeline, error handling\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/http/` |\n| Pattern | [ref:express-setup](./refs/express-setup.md) |\n| Dependencies | Express, cors, helmet |\n\n**Responsibilities:**\n- Express app configuration\n- Global middleware (CORS, security headers, body parsing)\n- Request/response logging\n- Global error handler\n- Health check endpoint\n\n**Key Files:**\n```\nsrc/foundation/http/\n├── app.ts              # Express app factory\n├── middleware/\n│   ├── cors.ts         # CORS configuration\n│   ├── security.ts     # Helmet, rate limiting\n│   └── logging.ts      # Request logging\n├── errors/\n│   ├── AppError.ts     # Base error class\n│   └── handler.ts      # Global error handler\n└── index.ts            # Public exports\n```\n\n---\n\n### c3-1.1: Auth Guard\n\n**Purpose:** Authentication & authorization middleware, Google OAuth integration\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/auth/` |\n| Pattern | [ref:auth-middleware](./refs/auth-middleware.md) |\n| Dependencies | passport, passport-google-oauth20, jsonwebtoken |\n\n**Responsibilities:**\n- Google OAuth callback handling\n- JWT token issuance and validation\n- Session management (Redis-backed)\n- Role-based access control (RBAC)\n- Workspace membership verification\n\n**Key Files:**\n```\nsrc/foundation/auth/\n├── strategies/\n│   └── google.ts       # Google OAuth strategy\n├── middleware/\n│   ├── authenticate.ts # JWT verification\n│   ├── authorize.ts    # RBAC checks\n│   └── workspace.ts    # Workspace access guard\n├── tokens.ts           # JWT utilities\n└── index.ts\n```\n\n**Interfaces:**\n```typescript\ninterface AuthenticatedRequest extends Request {\n  user: {\n    id: string;\n    email: string;\n    workspaceId?: string;\n    role?: WorkspaceRole;\n  };\n}\n```\n\n---\n\n### c3-1.2: DB Client\n\n**Purpose:** PostgreSQL connection management, query builder, migrations\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/db/` |\n| Pattern | [ref:repository-pattern](./refs/repository-pattern.md) |\n| Dependencies | pg, kysely (query builder) |\n\n**Responsibilities:**\n- Connection pool management\n- Type-safe query building\n- Transaction support\n- Migration runner\n- Multi-tenant query scoping\n\n**Key Files:**\n```\nsrc/foundation/db/\n├── client.ts           # Kysely instance\n├── migrations/         # Migration files\n├── types.ts            # Generated DB types\n├── scopes/\n│   └── tenant.ts       # Workspace scoping\n└── index.ts\n```\n\n**Multi-tenant Pattern:**\n```typescript\n// All queries automatically scoped to workspace\nconst tasks = await db\n  .selectFrom('tasks')\n  .where('workspace_id', '=', ctx.workspaceId) // Always applied\n  .selectAll()\n  .execute();\n```\n\n---\n\n### c3-1.3: Cache Layer\n\n**Purpose:** Redis caching abstraction, cache invalidation strategies\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/cache/` |\n| Pattern | [ref:cache-aside](./refs/cache-aside.md) |\n| Dependencies | ioredis |\n\n**Responsibilities:**\n- Cache read/write operations\n- TTL management\n- Cache key namespacing\n- Invalidation on mutations\n- Cache warming strategies\n\n**Key Files:**\n```\nsrc/foundation/cache/\n├── client.ts           # Redis connection\n├── keys.ts             # Key generation\n├── decorators.ts       # @Cacheable decorator\n└── index.ts\n```\n\n---\n\n### c3-1.4: Events Bus\n\n**Purpose:** In-process event bus, Redis pub/sub for cross-instance events\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/events/` |\n| Pattern | [ref:event-bus](./refs/event-bus.md) |\n| Dependencies | ioredis, eventemitter3 |\n\n**Responsibilities:**\n- Domain event publishing\n- In-process event handling\n- Cross-instance event broadcast (Redis pub/sub)\n- Event replay for late subscribers\n\n**Key Files:**\n```\nsrc/foundation/events/\n├── bus.ts              # Event bus implementation\n├── types.ts            # Event type definitions\n├── redis-adapter.ts    # Redis pub/sub bridge\n└── index.ts\n```\n\n**Event Types:**\n```typescript\ntype DomainEvent =\n  | { type: 'task.created'; payload: Task }\n  | { type: 'task.updated'; payload: Task }\n  | { type: 'board.updated'; payload: Board }\n  | { type: 'user.joined'; payload: { userId: string; workspaceId: string } };\n```\n\n---\n\n## Feature Components\n\n### c3-1.5: Workspace Module\n\n**Purpose:** Team/workspace management, invitations, member roles\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/workspace/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Workspace |\n\n**Responsibilities:**\n- Workspace CRUD\n- Member invitation flow\n- Role assignment (owner, admin, member)\n- Workspace settings\n\n**Key Files:**\n```\nsrc/modules/workspace/\n├── workspace.controller.ts\n├── workspace.service.ts\n├── workspace.repository.ts\n├── workspace.schema.ts      # Zod validation\n├── workspace.types.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/workspaces | Create workspace |\n| GET | /api/workspaces | List user's workspaces |\n| GET | /api/workspaces/:id | Get workspace details |\n| POST | /api/workspaces/:id/invite | Invite member |\n| PUT | /api/workspaces/:id/members/:userId | Update member role |\n\n---\n\n### c3-1.6: Board Module\n\n**Purpose:** Kanban board management, columns, board sharing\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/board/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Board |\n\n**Responsibilities:**\n- Board CRUD\n- Column management\n- Board access control\n- Board templates\n\n**Key Files:**\n```\nsrc/modules/board/\n├── board.controller.ts\n├── board.service.ts\n├── board.repository.ts\n├── column.service.ts\n├── board.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/boards | Create board |\n| GET | /api/boards | List workspace boards |\n| GET | /api/boards/:id | Get board with columns |\n| PUT | /api/boards/:id | Update board |\n| POST | /api/boards/:id/columns | Add column |\n| PUT | /api/boards/:id/columns/reorder | Reorder columns |\n\n---\n\n### c3-1.7: Task Module\n\n**Purpose:** Task CRUD, assignments, due dates, comments\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/task/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Task |\n\n**Responsibilities:**\n- Task CRUD operations\n- Task assignment to members\n- Due date management\n- Task comments\n- Task movement between columns\n- Task search and filtering\n\n**Key Files:**\n```\nsrc/modules/task/\n├── task.controller.ts\n├── task.service.ts\n├── task.repository.ts\n├── comment.service.ts\n├── task.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/tasks | Create task |\n| GET | /api/boards/:boardId/tasks | List board tasks |\n| GET | /api/tasks/:id | Get task details |\n| PUT | /api/tasks/:id | Update task |\n| PUT | /api/tasks/:id/move | Move to column |\n| POST | /api/tasks/:id/comments | Add comment |\n| PUT | /api/tasks/:id/assign | Assign member |\n\n**Domain Events Emitted:**\n- `task.created`\n- `task.updated`\n- `task.moved`\n- `task.assigned`\n\n---\n\n### c3-1.8: Realtime Module\n\n**Purpose:** WebSocket server, presence tracking, live updates\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/realtime/` |\n| Pattern | [ref:websocket-handler](./refs/websocket-handler.md) |\n| Bounded Context | Realtime |\n\n**Responsibilities:**\n- WebSocket connection management\n- Room-based subscriptions (per board)\n- Presence tracking (who's viewing)\n- Broadcasting domain events to clients\n- Connection authentication\n\n**Key Files:**\n```\nsrc/modules/realtime/\n├── realtime.gateway.ts     # WebSocket server\n├── rooms.ts                # Room management\n├── presence.ts             # User presence\n├── handlers/\n│   ├── board.handler.ts    # Board subscriptions\n│   └── task.handler.ts     # Task updates\n└── index.ts\n```\n\n**WebSocket Events:**\n| Event | Direction | Description |\n|-------|-----------|-------------|\n| subscribe:board | Client → Server | Join board room |\n| unsubscribe:board | Client → Server | Leave board room |\n| task:updated | Server → Client | Task changed |\n| presence:update | Server → Client | User joined/left |\n\n---\n\n### c3-1.9: User Module\n\n**Purpose:** User profile management, preferences, activity\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/user/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | User |\n\n**Responsibilities:**\n- User profile CRUD\n- User preferences (notifications, theme)\n- Avatar management\n- Activity history\n\n**Key Files:**\n```\nsrc/modules/user/\n├── user.controller.ts\n├── user.service.ts\n├── user.repository.ts\n├── user.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| GET | /api/users/me | Get current user |\n| PUT | /api/users/me | Update profile |\n| PUT | /api/users/me/preferences | Update preferences |\n\n---\n\n## Web App Components [c3-0]\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                          Web Application [c3-0]                             │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FOUNDATION                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │   │\n│  │  │  API     │ │  Auth    │ │  State   │ │  Real-   │               │   │\n│  │  │  Client  │ │  Context │ │  Store   │ │  time    │               │   │\n│  │  │  c3-0.0  │ │  c3-0.1  │ │  c3-0.2  │ │  c3-0.3  │               │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURES                                        │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Board      │ │   Task       │ │   Workspace  │                 │   │\n│  │  │   Feature    │ │   Feature    │ │   Feature    │                 │   │\n│  │  │   c3-0.4     │ │   c3-0.5     │ │   c3-0.6     │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### c3-0.0: API Client\n- Axios/fetch wrapper with auth headers\n- Request/response interceptors\n- Error handling\n\n### c3-0.1: Auth Context\n- Google OAuth login flow\n- Token storage and refresh\n- Protected routes\n\n### c3-0.2: State Store\n- React Query for server state\n- Zustand for client state\n- Optimistic updates\n\n### c3-0.3: Realtime Client\n- WebSocket connection manager\n- Reconnection logic\n- Event handlers\n\n### c3-0.4: Board Feature\n- Board list page\n- Kanban board view\n- Drag-and-drop columns\n\n### c3-0.5: Task Feature\n- Task cards\n- Task detail modal\n- Task creation form\n\n### c3-0.6: Workspace Feature\n- Workspace settings\n- Member management\n- Invitation flow\n\n---\n\n**Next**: See [adrs/adr-000.md](./adrs/adr-000.md) for the system blueprint\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:29:07.393Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/c3-components.md",
        "content": "# C3 Components: TaskFlow\n\n> Internal structure of containers, organized by Foundation and Feature modules\n\n## Component Overview\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         API Server [c3-1]                                   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                     FOUNDATION LAYER                                 │   │\n│  │  Cross-cutting concerns shared by all feature modules                │   │\n│  │                                                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │\n│  │  │  HTTP    │ │  Auth    │ │  DB      │ │  Cache   │ │  Events  │  │   │\n│  │  │  Core    │ │  Guard   │ │  Client  │ │  Layer   │ │  Bus     │  │   │\n│  │  │  c3-1.0  │ │  c3-1.1  │ │  c3-1.2  │ │  c3-1.3  │ │  c3-1.4  │  │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURE LAYER                                   │   │\n│  │  Domain modules with clear boundaries (future microservices)         │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Workspace  │ │    Board     │ │    Task      │                 │   │\n│  │  │    Module    │ │    Module    │ │    Module    │                 │   │\n│  │  │    c3-1.5    │ │    c3-1.6    │ │    c3-1.7    │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐                                  │   │\n│  │  │   Realtime   │ │    User      │                                  │   │\n│  │  │    Module    │ │    Module    │                                  │   │\n│  │  │    c3-1.8    │ │    c3-1.9    │                                  │   │\n│  │  └──────────────┘ └──────────────┘                                  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Foundation Components\n\n### c3-1.0: HTTP Core\n\n**Purpose:** Express application setup, middleware pipeline, error handling\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/http/` |\n| Pattern | [ref:express-setup](./refs/express-setup.md) |\n| Dependencies | Express, cors, helmet |\n\n**Responsibilities:**\n- Express app configuration\n- Global middleware (CORS, security headers, body parsing)\n- Request/response logging\n- Global error handler\n- Health check endpoint\n\n**Key Files:**\n```\nsrc/foundation/http/\n├── app.ts              # Express app factory\n├── middleware/\n│   ├── cors.ts         # CORS configuration\n│   ├── security.ts     # Helmet, rate limiting\n│   └── logging.ts      # Request logging\n├── errors/\n│   ├── AppError.ts     # Base error class\n│   └── handler.ts      # Global error handler\n└── index.ts            # Public exports\n```\n\n---\n\n### c3-1.1: Auth Guard\n\n**Purpose:** Authentication & authorization middleware, Google OAuth integration\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/auth/` |\n| Pattern | [ref:auth-middleware](./refs/auth-middleware.md) |\n| Dependencies | passport, passport-google-oauth20, jsonwebtoken |\n\n**Responsibilities:**\n- Google OAuth callback handling\n- JWT token issuance and validation\n- Session management (Redis-backed)\n- Role-based access control (RBAC)\n- Workspace membership verification\n\n**Key Files:**\n```\nsrc/foundation/auth/\n├── strategies/\n│   └── google.ts       # Google OAuth strategy\n├── middleware/\n│   ├── authenticate.ts # JWT verification\n│   ├── authorize.ts    # RBAC checks\n│   └── workspace.ts    # Workspace access guard\n├── tokens.ts           # JWT utilities\n└── index.ts\n```\n\n**Interfaces:**\n```typescript\ninterface AuthenticatedRequest extends Request {\n  user: {\n    id: string;\n    email: string;\n    workspaceId?: string;\n    role?: WorkspaceRole;\n  };\n}\n```\n\n---\n\n### c3-1.2: DB Client\n\n**Purpose:** PostgreSQL connection management, query builder, migrations\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/db/` |\n| Pattern | [ref:repository-pattern](./refs/repository-pattern.md) |\n| Dependencies | pg, kysely (query builder) |\n\n**Responsibilities:**\n- Connection pool management\n- Type-safe query building\n- Transaction support\n- Migration runner\n- Multi-tenant query scoping\n\n**Key Files:**\n```\nsrc/foundation/db/\n├── client.ts           # Kysely instance\n├── migrations/         # Migration files\n├── types.ts            # Generated DB types\n├── scopes/\n│   └── tenant.ts       # Workspace scoping\n└── index.ts\n```\n\n**Multi-tenant Pattern:**\n```typescript\n// All queries automatically scoped to workspace\nconst tasks = await db\n  .selectFrom('tasks')\n  .where('workspace_id', '=', ctx.workspaceId) // Always applied\n  .selectAll()\n  .execute();\n```\n\n---\n\n### c3-1.3: Cache Layer\n\n**Purpose:** Redis caching abstraction, cache invalidation strategies\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/cache/` |\n| Pattern | [ref:cache-aside](./refs/cache-aside.md) |\n| Dependencies | ioredis |\n\n**Responsibilities:**\n- Cache read/write operations\n- TTL management\n- Cache key namespacing\n- Invalidation on mutations\n- Cache warming strategies\n\n**Key Files:**\n```\nsrc/foundation/cache/\n├── client.ts           # Redis connection\n├── keys.ts             # Key generation\n├── decorators.ts       # @Cacheable decorator\n└── index.ts\n```\n\n---\n\n### c3-1.4: Events Bus\n\n**Purpose:** In-process event bus, Redis pub/sub for cross-instance events\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/events/` |\n| Pattern | [ref:event-bus](./refs/event-bus.md) |\n| Dependencies | ioredis, eventemitter3 |\n\n**Responsibilities:**\n- Domain event publishing\n- In-process event handling\n- Cross-instance event broadcast (Redis pub/sub)\n- Event replay for late subscribers\n\n**Key Files:**\n```\nsrc/foundation/events/\n├── bus.ts              # Event bus implementation\n├── types.ts            # Event type definitions\n├── redis-adapter.ts    # Redis pub/sub bridge\n└── index.ts\n```\n\n**Event Types:**\n```typescript\ntype DomainEvent =\n  | { type: 'task.created'; payload: Task }\n  | { type: 'task.updated'; payload: Task }\n  | { type: 'board.updated'; payload: Board }\n  | { type: 'user.joined'; payload: { userId: string; workspaceId: string } };\n```\n\n---\n\n## Feature Components\n\n### c3-1.5: Workspace Module\n\n**Purpose:** Team/workspace management, invitations, member roles\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/workspace/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Workspace |\n\n**Responsibilities:**\n- Workspace CRUD\n- Member invitation flow\n- Role assignment (owner, admin, member)\n- Workspace settings\n\n**Key Files:**\n```\nsrc/modules/workspace/\n├── workspace.controller.ts\n├── workspace.service.ts\n├── workspace.repository.ts\n├── workspace.schema.ts      # Zod validation\n├── workspace.types.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/workspaces | Create workspace |\n| GET | /api/workspaces | List user's workspaces |\n| GET | /api/workspaces/:id | Get workspace details |\n| POST | /api/workspaces/:id/invite | Invite member |\n| PUT | /api/workspaces/:id/members/:userId | Update member role |\n\n---\n\n### c3-1.6: Board Module\n\n**Purpose:** Kanban board management, columns, board sharing\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/board/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Board |\n\n**Responsibilities:**\n- Board CRUD\n- Column management\n- Board access control\n- Board templates\n\n**Key Files:**\n```\nsrc/modules/board/\n├── board.controller.ts\n├── board.service.ts\n├── board.repository.ts\n├── column.service.ts\n├── board.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/boards | Create board |\n| GET | /api/boards | List workspace boards |\n| GET | /api/boards/:id | Get board with columns |\n| PUT | /api/boards/:id | Update board |\n| POST | /api/boards/:id/columns | Add column |\n| PUT | /api/boards/:id/columns/reorder | Reorder columns |\n\n---\n\n### c3-1.7: Task Module\n\n**Purpose:** Task CRUD, assignments, due dates, comments\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/task/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Task |\n\n**Responsibilities:**\n- Task CRUD operations\n- Task assignment to members\n- Due date management\n- Task comments\n- Task movement between columns\n- Task search and filtering\n\n**Key Files:**\n```\nsrc/modules/task/\n├── task.controller.ts\n├── task.service.ts\n├── task.repository.ts\n├── comment.service.ts\n├── task.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/tasks | Create task |\n| GET | /api/boards/:boardId/tasks | List board tasks |\n| GET | /api/tasks/:id | Get task details |\n| PUT | /api/tasks/:id | Update task |\n| PUT | /api/tasks/:id/move | Move to column |\n| POST | /api/tasks/:id/comments | Add comment |\n| PUT | /api/tasks/:id/assign | Assign member |\n\n**Domain Events Emitted:**\n- `task.created`\n- `task.updated`\n- `task.moved`\n- `task.assigned`\n\n---\n\n### c3-1.8: Realtime Module\n\n**Purpose:** WebSocket server, presence tracking, live updates\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/realtime/` |\n| Pattern | [ref:websocket-handler](./refs/websocket-handler.md) |\n| Bounded Context | Realtime |\n\n**Responsibilities:**\n- WebSocket connection management\n- Room-based subscriptions (per board)\n- Presence tracking (who's viewing)\n- Broadcasting domain events to clients\n- Connection authentication\n\n**Key Files:**\n```\nsrc/modules/realtime/\n├── realtime.gateway.ts     # WebSocket server\n├── rooms.ts                # Room management\n├── presence.ts             # User presence\n├── handlers/\n│   ├── board.handler.ts    # Board subscriptions\n│   └── task.handler.ts     # Task updates\n└── index.ts\n```\n\n**WebSocket Events:**\n| Event | Direction | Description |\n|-------|-----------|-------------|\n| subscribe:board | Client → Server | Join board room |\n| unsubscribe:board | Client → Server | Leave board room |\n| task:updated | Server → Client | Task changed |\n| presence:update | Server → Client | User joined/left |\n\n---\n\n### c3-1.9: User Module\n\n**Purpose:** User profile management, preferences, activity\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/user/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | User |\n\n**Responsibilities:**\n- User profile CRUD\n- User preferences (notifications, theme)\n- Avatar management\n- Activity history\n\n**Key Files:**\n```\nsrc/modules/user/\n├── user.controller.ts\n├── user.service.ts\n├── user.repository.ts\n├── user.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| GET | /api/users/me | Get current user |\n| PUT | /api/users/me | Update profile |\n| PUT | /api/users/me/preferences | Update preferences |\n\n---\n\n## Web App Components [c3-0]\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                          Web Application [c3-0]                             │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FOUNDATION                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │   │\n│  │  │  API     │ │  Auth    │ │  State   │ │  Real-   │               │   │\n│  │  │  Client  │ │  Context │ │  Store   │ │  time    │               │   │\n│  │  │  c3-0.0  │ │  c3-0.1  │ │  c3-0.2  │ │  c3-0.3  │               │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURES                                        │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Board      │ │   Task       │ │   Workspace  │                 │   │\n│  │  │   Feature    │ │   Feature    │ │   Feature    │                 │   │\n│  │  │   c3-0.4     │ │   c3-0.5     │ │   c3-0.6     │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### c3-0.0: API Client\n- Axios/fetch wrapper with auth headers\n- Request/response interceptors\n- Error handling\n\n### c3-0.1: Auth Context\n- Google OAuth login flow\n- Token storage and refresh\n- Protected routes\n\n### c3-0.2: State Store\n- React Query for server state\n- Zustand for client state\n- Optimistic updates\n\n### c3-0.3: Realtime Client\n- WebSocket connection manager\n- Reconnection logic\n- Event handlers\n\n### c3-0.4: Board Feature\n- Board list page\n- Kanban board view\n- Drag-and-drop columns\n\n### c3-0.5: Task Feature\n- Task cards\n- Task detail modal\n- Task creation form\n\n### c3-0.6: Workspace Feature\n- Workspace settings\n- Member management\n- Invitation flow\n\n---\n\n**Next**: See [adrs/adr-000.md](./adrs/adr-000.md) for the system blueprint\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/c3-components.md",
        "content": "# C3 Components: TaskFlow\n\n> Internal structure of containers, organized by Foundation and Feature modules\n\n## Component Overview\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         API Server [c3-1]                                   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                     FOUNDATION LAYER                                 │   │\n│  │  Cross-cutting concerns shared by all feature modules                │   │\n│  │                                                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │   │\n│  │  │  HTTP    │ │  Auth    │ │  DB      │ │  Cache   │ │  Events  │  │   │\n│  │  │  Core    │ │  Guard   │ │  Client  │ │  Layer   │ │  Bus     │  │   │\n│  │  │  c3-1.0  │ │  c3-1.1  │ │  c3-1.2  │ │  c3-1.3  │ │  c3-1.4  │  │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘ └──────────┘  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURE LAYER                                   │   │\n│  │  Domain modules with clear boundaries (future microservices)         │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Workspace  │ │    Board     │ │    Task      │                 │   │\n│  │  │    Module    │ │    Module    │ │    Module    │                 │   │\n│  │  │    c3-1.5    │ │    c3-1.6    │ │    c3-1.7    │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  │                                                                      │   │\n│  │  ┌──────────────┐ ┌──────────────┐                                  │   │\n│  │  │   Realtime   │ │    User      │                                  │   │\n│  │  │    Module    │ │    Module    │                                  │   │\n│  │  │    c3-1.8    │ │    c3-1.9    │                                  │   │\n│  │  └──────────────┘ └──────────────┘                                  │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## Foundation Components\n\n### c3-1.0: HTTP Core\n\n**Purpose:** Express application setup, middleware pipeline, error handling\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/http/` |\n| Pattern | [ref:express-setup](./refs/express-setup.md) |\n| Dependencies | Express, cors, helmet |\n\n**Responsibilities:**\n- Express app configuration\n- Global middleware (CORS, security headers, body parsing)\n- Request/response logging\n- Global error handler\n- Health check endpoint\n\n**Key Files:**\n```\nsrc/foundation/http/\n├── app.ts              # Express app factory\n├── middleware/\n│   ├── cors.ts         # CORS configuration\n│   ├── security.ts     # Helmet, rate limiting\n│   └── logging.ts      # Request logging\n├── errors/\n│   ├── AppError.ts     # Base error class\n│   └── handler.ts      # Global error handler\n└── index.ts            # Public exports\n```\n\n---\n\n### c3-1.1: Auth Guard\n\n**Purpose:** Authentication & authorization middleware, Google OAuth integration\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/auth/` |\n| Pattern | [ref:auth-middleware](./refs/auth-middleware.md) |\n| Dependencies | passport, passport-google-oauth20, jsonwebtoken |\n\n**Responsibilities:**\n- Google OAuth callback handling\n- JWT token issuance and validation\n- Session management (Redis-backed)\n- Role-based access control (RBAC)\n- Workspace membership verification\n\n**Key Files:**\n```\nsrc/foundation/auth/\n├── strategies/\n│   └── google.ts       # Google OAuth strategy\n├── middleware/\n│   ├── authenticate.ts # JWT verification\n│   ├── authorize.ts    # RBAC checks\n│   └── workspace.ts    # Workspace access guard\n├── tokens.ts           # JWT utilities\n└── index.ts\n```\n\n**Interfaces:**\n```typescript\ninterface AuthenticatedRequest extends Request {\n  user: {\n    id: string;\n    email: string;\n    workspaceId?: string;\n    role?: WorkspaceRole;\n  };\n}\n```\n\n---\n\n### c3-1.2: DB Client\n\n**Purpose:** PostgreSQL connection management, query builder, migrations\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/db/` |\n| Pattern | [ref:repository-pattern](./refs/repository-pattern.md) |\n| Dependencies | pg, kysely (query builder) |\n\n**Responsibilities:**\n- Connection pool management\n- Type-safe query building\n- Transaction support\n- Migration runner\n- Multi-tenant query scoping\n\n**Key Files:**\n```\nsrc/foundation/db/\n├── client.ts           # Kysely instance\n├── migrations/         # Migration files\n├── types.ts            # Generated DB types\n├── scopes/\n│   └── tenant.ts       # Workspace scoping\n└── index.ts\n```\n\n**Multi-tenant Pattern:**\n```typescript\n// All queries automatically scoped to workspace\nconst tasks = await db\n  .selectFrom('tasks')\n  .where('workspace_id', '=', ctx.workspaceId) // Always applied\n  .selectAll()\n  .execute();\n```\n\n---\n\n### c3-1.3: Cache Layer\n\n**Purpose:** Redis caching abstraction, cache invalidation strategies\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/cache/` |\n| Pattern | [ref:cache-aside](./refs/cache-aside.md) |\n| Dependencies | ioredis |\n\n**Responsibilities:**\n- Cache read/write operations\n- TTL management\n- Cache key namespacing\n- Invalidation on mutations\n- Cache warming strategies\n\n**Key Files:**\n```\nsrc/foundation/cache/\n├── client.ts           # Redis connection\n├── keys.ts             # Key generation\n├── decorators.ts       # @Cacheable decorator\n└── index.ts\n```\n\n---\n\n### c3-1.4: Events Bus\n\n**Purpose:** In-process event bus, Redis pub/sub for cross-instance events\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/foundation/events/` |\n| Pattern | [ref:event-bus](./refs/event-bus.md) |\n| Dependencies | ioredis, eventemitter3 |\n\n**Responsibilities:**\n- Domain event publishing\n- In-process event handling\n- Cross-instance event broadcast (Redis pub/sub)\n- Event replay for late subscribers\n\n**Key Files:**\n```\nsrc/foundation/events/\n├── bus.ts              # Event bus implementation\n├── types.ts            # Event type definitions\n├── redis-adapter.ts    # Redis pub/sub bridge\n└── index.ts\n```\n\n**Event Types:**\n```typescript\ntype DomainEvent =\n  | { type: 'task.created'; payload: Task }\n  | { type: 'task.updated'; payload: Task }\n  | { type: 'board.updated'; payload: Board }\n  | { type: 'user.joined'; payload: { userId: string; workspaceId: string } };\n```\n\n---\n\n## Feature Components\n\n### c3-1.5: Workspace Module\n\n**Purpose:** Team/workspace management, invitations, member roles\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/workspace/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Workspace |\n\n**Responsibilities:**\n- Workspace CRUD\n- Member invitation flow\n- Role assignment (owner, admin, member)\n- Workspace settings\n\n**Key Files:**\n```\nsrc/modules/workspace/\n├── workspace.controller.ts\n├── workspace.service.ts\n├── workspace.repository.ts\n├── workspace.schema.ts      # Zod validation\n├── workspace.types.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/workspaces | Create workspace |\n| GET | /api/workspaces | List user's workspaces |\n| GET | /api/workspaces/:id | Get workspace details |\n| POST | /api/workspaces/:id/invite | Invite member |\n| PUT | /api/workspaces/:id/members/:userId | Update member role |\n\n---\n\n### c3-1.6: Board Module\n\n**Purpose:** Kanban board management, columns, board sharing\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/board/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Board |\n\n**Responsibilities:**\n- Board CRUD\n- Column management\n- Board access control\n- Board templates\n\n**Key Files:**\n```\nsrc/modules/board/\n├── board.controller.ts\n├── board.service.ts\n├── board.repository.ts\n├── column.service.ts\n├── board.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/boards | Create board |\n| GET | /api/boards | List workspace boards |\n| GET | /api/boards/:id | Get board with columns |\n| PUT | /api/boards/:id | Update board |\n| POST | /api/boards/:id/columns | Add column |\n| PUT | /api/boards/:id/columns/reorder | Reorder columns |\n\n---\n\n### c3-1.7: Task Module\n\n**Purpose:** Task CRUD, assignments, due dates, comments\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/task/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | Task |\n\n**Responsibilities:**\n- Task CRUD operations\n- Task assignment to members\n- Due date management\n- Task comments\n- Task movement between columns\n- Task search and filtering\n\n**Key Files:**\n```\nsrc/modules/task/\n├── task.controller.ts\n├── task.service.ts\n├── task.repository.ts\n├── comment.service.ts\n├── task.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| POST | /api/tasks | Create task |\n| GET | /api/boards/:boardId/tasks | List board tasks |\n| GET | /api/tasks/:id | Get task details |\n| PUT | /api/tasks/:id | Update task |\n| PUT | /api/tasks/:id/move | Move to column |\n| POST | /api/tasks/:id/comments | Add comment |\n| PUT | /api/tasks/:id/assign | Assign member |\n\n**Domain Events Emitted:**\n- `task.created`\n- `task.updated`\n- `task.moved`\n- `task.assigned`\n\n---\n\n### c3-1.8: Realtime Module\n\n**Purpose:** WebSocket server, presence tracking, live updates\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/realtime/` |\n| Pattern | [ref:websocket-handler](./refs/websocket-handler.md) |\n| Bounded Context | Realtime |\n\n**Responsibilities:**\n- WebSocket connection management\n- Room-based subscriptions (per board)\n- Presence tracking (who's viewing)\n- Broadcasting domain events to clients\n- Connection authentication\n\n**Key Files:**\n```\nsrc/modules/realtime/\n├── realtime.gateway.ts     # WebSocket server\n├── rooms.ts                # Room management\n├── presence.ts             # User presence\n├── handlers/\n│   ├── board.handler.ts    # Board subscriptions\n│   └── task.handler.ts     # Task updates\n└── index.ts\n```\n\n**WebSocket Events:**\n| Event | Direction | Description |\n|-------|-----------|-------------|\n| subscribe:board | Client → Server | Join board room |\n| unsubscribe:board | Client → Server | Leave board room |\n| task:updated | Server → Client | Task changed |\n| presence:update | Server → Client | User joined/left |\n\n---\n\n### c3-1.9: User Module\n\n**Purpose:** User profile management, preferences, activity\n\n| Aspect | Detail |\n|--------|--------|\n| Location | `src/modules/user/` |\n| Pattern | [ref:module-structure](./refs/module-structure.md) |\n| Bounded Context | User |\n\n**Responsibilities:**\n- User profile CRUD\n- User preferences (notifications, theme)\n- Avatar management\n- Activity history\n\n**Key Files:**\n```\nsrc/modules/user/\n├── user.controller.ts\n├── user.service.ts\n├── user.repository.ts\n├── user.schema.ts\n└── index.ts\n```\n\n**API Endpoints:**\n| Method | Path | Description |\n|--------|------|-------------|\n| GET | /api/users/me | Get current user |\n| PUT | /api/users/me | Update profile |\n| PUT | /api/users/me/preferences | Update preferences |\n\n---\n\n## Web App Components [c3-0]\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                          Web Application [c3-0]                             │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FOUNDATION                                      │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐               │   │\n│  │  │  API     │ │  Auth    │ │  State   │ │  Real-   │               │   │\n│  │  │  Client  │ │  Context │ │  Store   │ │  time    │               │   │\n│  │  │  c3-0.0  │ │  c3-0.1  │ │  c3-0.2  │ │  c3-0.3  │               │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘               │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      FEATURES                                        │   │\n│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐                 │   │\n│  │  │   Board      │ │   Task       │ │   Workspace  │                 │   │\n│  │  │   Feature    │ │   Feature    │ │   Feature    │                 │   │\n│  │  │   c3-0.4     │ │   c3-0.5     │ │   c3-0.6     │                 │   │\n│  │  └──────────────┘ └──────────────┘ └──────────────┘                 │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### c3-0.0: API Client\n- Axios/fetch wrapper with auth headers\n- Request/response interceptors\n- Error handling\n\n### c3-0.1: Auth Context\n- Google OAuth login flow\n- Token storage and refresh\n- Protected routes\n\n### c3-0.2: State Store\n- React Query for server state\n- Zustand for client state\n- Optimistic updates\n\n### c3-0.3: Realtime Client\n- WebSocket connection manager\n- Reconnection logic\n- Event handlers\n\n### c3-0.4: Board Feature\n- Board list page\n- Kanban board view\n- Drag-and-drop columns\n\n### c3-0.5: Task Feature\n- Task cards\n- Task detail modal\n- Task creation form\n\n### c3-0.6: Workspace Feature\n- Workspace settings\n- Member management\n- Invitation flow\n\n---\n\n**Next**: See [adrs/adr-000.md](./adrs/adr-000.md) for the system blueprint\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:29:12.861Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "in_progress",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:29:12.869Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "in_progress",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "in_progress",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "pending",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "in_progress",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:29:50.032Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/adrs/adr-000.md",
        "content": "# ADR-000: TaskFlow System Blueprint\n\n**Status:** Accepted\n**Date:** 2025-01-12\n**Deciders:** System Architects\n\n## Context\n\nWe're building **TaskFlow**, a task management SaaS for small teams (5-50 members). The system needs to support:\n\n- Real-time collaboration on task boards\n- Multi-tenant isolation (each team has its own workspace)\n- API-first design for future mobile apps\n- Scalability to 100+ concurrent users per workspace\n\nThis ADR establishes the foundational architecture that all subsequent decisions will build upon.\n\n## Decision\n\nWe will build TaskFlow as a **modular monolith** with the following architecture:\n\n### Technology Stack\n\n| Layer | Technology | Rationale |\n|-------|------------|-----------|\n| Frontend | React 18 + TypeScript + Vite | Modern SPA with type safety, fast dev experience |\n| Backend | Node.js + Express + TypeScript | JavaScript ecosystem, async I/O for real-time |\n| Database | PostgreSQL 15+ | ACID compliance, JSONB for flexibility, RLS for multi-tenancy |\n| Cache | Redis 7+ | Caching + pub/sub for real-time broadcast |\n| Auth | Google OAuth + JWT | Trusted identity provider, stateless tokens |\n| Real-time | WebSocket (ws/socket.io) | Bi-directional real-time communication |\n\n### Architecture Style: Modular Monolith\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                     Single Deployment Unit                       │\n│                                                                  │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Foundation Layer                       │   │\n│  │  HTTP Core │ Auth Guard │ DB Client │ Cache │ Events     │   │\n│  └──────────────────────────────────────────────────────────┘   │\n│                              │                                   │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Feature Modules                        │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │   │\n│  │  │Workspace │ │  Board   │ │   Task   │ │ Realtime │    │   │\n│  │  │  Module  │ │  Module  │ │  Module  │ │  Module  │    │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘    │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**Key principles:**\n1. **Module Boundaries**: Each feature module is self-contained with its own controller, service, repository, and types\n2. **Shared Foundation**: Cross-cutting concerns (auth, db, cache) are in foundation layer\n3. **Event-Driven Communication**: Modules communicate via domain events, not direct imports\n4. **Future Decomposition**: Each module can become a microservice by extracting it with its own database\n\n### Multi-Tenancy Strategy\n\n- **Shared Database, Tenant Column**: All tables have `workspace_id` column\n- **Query Scoping**: All queries automatically filtered by workspace context\n- **Row-Level Security**: PostgreSQL RLS as defense-in-depth\n\n```sql\n-- Every table includes workspace_id\nCREATE TABLE tasks (\n  id UUID PRIMARY KEY,\n  workspace_id UUID NOT NULL REFERENCES workspaces(id),\n  title TEXT NOT NULL,\n  -- ...\n);\n\n-- RLS policy\nALTER TABLE tasks ENABLE ROW LEVEL SECURITY;\nCREATE POLICY workspace_isolation ON tasks\n  USING (workspace_id = current_setting('app.workspace_id')::UUID);\n```\n\n### Real-Time Architecture\n\n```\n┌─────────────┐     WebSocket      ┌─────────────┐\n│   Client 1  │◄──────────────────►│             │\n└─────────────┘                    │             │\n                                   │   Server    │\n┌─────────────┐     WebSocket      │   Instance  │\n│   Client 2  │◄──────────────────►│      1      │\n└─────────────┘                    │             │\n                                   └──────┬──────┘\n                                          │\n                                   Redis Pub/Sub\n                                          │\n                                   ┌──────┴──────┐\n┌─────────────┐     WebSocket      │   Server    │\n│   Client 3  │◄──────────────────►│   Instance  │\n└─────────────┘                    │      2      │\n                                   └─────────────┘\n```\n\n- **Room-Based Subscriptions**: Clients subscribe to specific board rooms\n- **Redis Pub/Sub**: Enables broadcast across multiple server instances\n- **Presence Tracking**: Know who's viewing which board\n\n### API Design\n\n- **REST API**: CRUD operations, suitable for mobile apps\n- **Resource-Oriented**: `/api/workspaces/:id/boards/:boardId/tasks`\n- **Versioning**: URL path versioning (`/api/v1/...`)\n- **Pagination**: Cursor-based for lists\n\n### Security Layers\n\n1. **Authentication**: Google OAuth → JWT token\n2. **Authorization**: RBAC (Owner, Admin, Member roles)\n3. **Workspace Guard**: Verify membership before any operation\n4. **Rate Limiting**: Per-user and per-workspace limits\n5. **Input Validation**: Zod schemas on all endpoints\n\n## Consequences\n\n### Positive\n\n- **Rapid Development**: Single codebase, simple deployment\n- **Type Safety**: TypeScript end-to-end reduces bugs\n- **Real-Time Built-In**: WebSocket + Redis ready from day one\n- **Clear Boundaries**: Module structure guides team organization\n- **Future Flexibility**: Can extract modules to microservices when needed\n\n### Negative\n\n- **Scaling Limits**: Single process limits (mitigated by horizontal scaling with Redis)\n- **Deployment Coupling**: All modules deploy together\n- **Shared Database**: Schema changes affect all modules\n\n### Risks & Mitigations\n\n| Risk | Mitigation |\n|------|------------|\n| Module coupling creeping in | Enforce module boundaries via lint rules |\n| Real-time scaling issues | Redis pub/sub enables horizontal scaling |\n| Multi-tenant data leaks | RLS + automated testing of tenant isolation |\n| OAuth provider dependency | Can add more providers later |\n\n## Implementation Phases\n\n### Phase 1: Foundation (Week 1-2)\n- [ ] Project setup (TypeScript, ESLint, Prettier)\n- [ ] Foundation layer (HTTP, Auth, DB, Cache)\n- [ ] Google OAuth integration\n- [ ] Basic user model\n\n### Phase 2: Core Features (Week 3-4)\n- [ ] Workspace module\n- [ ] Board module\n- [ ] Task module (CRUD)\n- [ ] Basic frontend with auth\n\n### Phase 3: Real-Time (Week 5-6)\n- [ ] WebSocket server\n- [ ] Board subscriptions\n- [ ] Live task updates\n- [ ] Presence indicators\n\n### Phase 4: Polish (Week 7-8)\n- [ ] Task comments\n- [ ] Member invitations\n- [ ] Notifications\n- [ ] Performance optimization\n\n## Related Documents\n\n- [c3-context.md](../c3-context.md) - System boundary and actors\n- [c3-containers.md](../c3-containers.md) - Deployable units\n- [c3-components.md](../c3-components.md) - Internal structure\n\n## References\n\n- [ref:module-structure](../refs/module-structure.md) - Standard module layout\n- [ref:repository-pattern](../refs/repository-pattern.md) - Data access pattern\n- [ref:auth-middleware](../refs/auth-middleware.md) - Authentication setup\n- [ref:websocket-handler](../refs/websocket-handler.md) - WebSocket patterns\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:29:50.046Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/adrs/adr-000.md",
        "content": "# ADR-000: TaskFlow System Blueprint\n\n**Status:** Accepted\n**Date:** 2025-01-12\n**Deciders:** System Architects\n\n## Context\n\nWe're building **TaskFlow**, a task management SaaS for small teams (5-50 members). The system needs to support:\n\n- Real-time collaboration on task boards\n- Multi-tenant isolation (each team has its own workspace)\n- API-first design for future mobile apps\n- Scalability to 100+ concurrent users per workspace\n\nThis ADR establishes the foundational architecture that all subsequent decisions will build upon.\n\n## Decision\n\nWe will build TaskFlow as a **modular monolith** with the following architecture:\n\n### Technology Stack\n\n| Layer | Technology | Rationale |\n|-------|------------|-----------|\n| Frontend | React 18 + TypeScript + Vite | Modern SPA with type safety, fast dev experience |\n| Backend | Node.js + Express + TypeScript | JavaScript ecosystem, async I/O for real-time |\n| Database | PostgreSQL 15+ | ACID compliance, JSONB for flexibility, RLS for multi-tenancy |\n| Cache | Redis 7+ | Caching + pub/sub for real-time broadcast |\n| Auth | Google OAuth + JWT | Trusted identity provider, stateless tokens |\n| Real-time | WebSocket (ws/socket.io) | Bi-directional real-time communication |\n\n### Architecture Style: Modular Monolith\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                     Single Deployment Unit                       │\n│                                                                  │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Foundation Layer                       │   │\n│  │  HTTP Core │ Auth Guard │ DB Client │ Cache │ Events     │   │\n│  └──────────────────────────────────────────────────────────┘   │\n│                              │                                   │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Feature Modules                        │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │   │\n│  │  │Workspace │ │  Board   │ │   Task   │ │ Realtime │    │   │\n│  │  │  Module  │ │  Module  │ │  Module  │ │  Module  │    │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘    │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**Key principles:**\n1. **Module Boundaries**: Each feature module is self-contained with its own controller, service, repository, and types\n2. **Shared Foundation**: Cross-cutting concerns (auth, db, cache) are in foundation layer\n3. **Event-Driven Communication**: Modules communicate via domain events, not direct imports\n4. **Future Decomposition**: Each module can become a microservice by extracting it with its own database\n\n### Multi-Tenancy Strategy\n\n- **Shared Database, Tenant Column**: All tables have `workspace_id` column\n- **Query Scoping**: All queries automatically filtered by workspace context\n- **Row-Level Security**: PostgreSQL RLS as defense-in-depth\n\n```sql\n-- Every table includes workspace_id\nCREATE TABLE tasks (\n  id UUID PRIMARY KEY,\n  workspace_id UUID NOT NULL REFERENCES workspaces(id),\n  title TEXT NOT NULL,\n  -- ...\n);\n\n-- RLS policy\nALTER TABLE tasks ENABLE ROW LEVEL SECURITY;\nCREATE POLICY workspace_isolation ON tasks\n  USING (workspace_id = current_setting('app.workspace_id')::UUID);\n```\n\n### Real-Time Architecture\n\n```\n┌─────────────┐     WebSocket      ┌─────────────┐\n│   Client 1  │◄──────────────────►│             │\n└─────────────┘                    │             │\n                                   │   Server    │\n┌─────────────┐     WebSocket      │   Instance  │\n│   Client 2  │◄──────────────────►│      1      │\n└─────────────┘                    │             │\n                                   └──────┬──────┘\n                                          │\n                                   Redis Pub/Sub\n                                          │\n                                   ┌──────┴──────┐\n┌─────────────┐     WebSocket      │   Server    │\n│   Client 3  │◄──────────────────►│   Instance  │\n└─────────────┘                    │      2      │\n                                   └─────────────┘\n```\n\n- **Room-Based Subscriptions**: Clients subscribe to specific board rooms\n- **Redis Pub/Sub**: Enables broadcast across multiple server instances\n- **Presence Tracking**: Know who's viewing which board\n\n### API Design\n\n- **REST API**: CRUD operations, suitable for mobile apps\n- **Resource-Oriented**: `/api/workspaces/:id/boards/:boardId/tasks`\n- **Versioning**: URL path versioning (`/api/v1/...`)\n- **Pagination**: Cursor-based for lists\n\n### Security Layers\n\n1. **Authentication**: Google OAuth → JWT token\n2. **Authorization**: RBAC (Owner, Admin, Member roles)\n3. **Workspace Guard**: Verify membership before any operation\n4. **Rate Limiting**: Per-user and per-workspace limits\n5. **Input Validation**: Zod schemas on all endpoints\n\n## Consequences\n\n### Positive\n\n- **Rapid Development**: Single codebase, simple deployment\n- **Type Safety**: TypeScript end-to-end reduces bugs\n- **Real-Time Built-In**: WebSocket + Redis ready from day one\n- **Clear Boundaries**: Module structure guides team organization\n- **Future Flexibility**: Can extract modules to microservices when needed\n\n### Negative\n\n- **Scaling Limits**: Single process limits (mitigated by horizontal scaling with Redis)\n- **Deployment Coupling**: All modules deploy together\n- **Shared Database**: Schema changes affect all modules\n\n### Risks & Mitigations\n\n| Risk | Mitigation |\n|------|------------|\n| Module coupling creeping in | Enforce module boundaries via lint rules |\n| Real-time scaling issues | Redis pub/sub enables horizontal scaling |\n| Multi-tenant data leaks | RLS + automated testing of tenant isolation |\n| OAuth provider dependency | Can add more providers later |\n\n## Implementation Phases\n\n### Phase 1: Foundation (Week 1-2)\n- [ ] Project setup (TypeScript, ESLint, Prettier)\n- [ ] Foundation layer (HTTP, Auth, DB, Cache)\n- [ ] Google OAuth integration\n- [ ] Basic user model\n\n### Phase 2: Core Features (Week 3-4)\n- [ ] Workspace module\n- [ ] Board module\n- [ ] Task module (CRUD)\n- [ ] Basic frontend with auth\n\n### Phase 3: Real-Time (Week 5-6)\n- [ ] WebSocket server\n- [ ] Board subscriptions\n- [ ] Live task updates\n- [ ] Presence indicators\n\n### Phase 4: Polish (Week 7-8)\n- [ ] Task comments\n- [ ] Member invitations\n- [ ] Notifications\n- [ ] Performance optimization\n\n## Related Documents\n\n- [c3-context.md](../c3-context.md) - System boundary and actors\n- [c3-containers.md](../c3-containers.md) - Deployable units\n- [c3-components.md](../c3-components.md) - Internal structure\n\n## References\n\n- [ref:module-structure](../refs/module-structure.md) - Standard module layout\n- [ref:repository-pattern](../refs/repository-pattern.md) - Data access pattern\n- [ref:auth-middleware](../refs/auth-middleware.md) - Authentication setup\n- [ref:websocket-handler](../refs/websocket-handler.md) - WebSocket patterns\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/adrs/adr-000.md",
        "content": "# ADR-000: TaskFlow System Blueprint\n\n**Status:** Accepted\n**Date:** 2025-01-12\n**Deciders:** System Architects\n\n## Context\n\nWe're building **TaskFlow**, a task management SaaS for small teams (5-50 members). The system needs to support:\n\n- Real-time collaboration on task boards\n- Multi-tenant isolation (each team has its own workspace)\n- API-first design for future mobile apps\n- Scalability to 100+ concurrent users per workspace\n\nThis ADR establishes the foundational architecture that all subsequent decisions will build upon.\n\n## Decision\n\nWe will build TaskFlow as a **modular monolith** with the following architecture:\n\n### Technology Stack\n\n| Layer | Technology | Rationale |\n|-------|------------|-----------|\n| Frontend | React 18 + TypeScript + Vite | Modern SPA with type safety, fast dev experience |\n| Backend | Node.js + Express + TypeScript | JavaScript ecosystem, async I/O for real-time |\n| Database | PostgreSQL 15+ | ACID compliance, JSONB for flexibility, RLS for multi-tenancy |\n| Cache | Redis 7+ | Caching + pub/sub for real-time broadcast |\n| Auth | Google OAuth + JWT | Trusted identity provider, stateless tokens |\n| Real-time | WebSocket (ws/socket.io) | Bi-directional real-time communication |\n\n### Architecture Style: Modular Monolith\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                     Single Deployment Unit                       │\n│                                                                  │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Foundation Layer                       │   │\n│  │  HTTP Core │ Auth Guard │ DB Client │ Cache │ Events     │   │\n│  └──────────────────────────────────────────────────────────┘   │\n│                              │                                   │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │                    Feature Modules                        │   │\n│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐    │   │\n│  │  │Workspace │ │  Board   │ │   Task   │ │ Realtime │    │   │\n│  │  │  Module  │ │  Module  │ │  Module  │ │  Module  │    │   │\n│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘    │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**Key principles:**\n1. **Module Boundaries**: Each feature module is self-contained with its own controller, service, repository, and types\n2. **Shared Foundation**: Cross-cutting concerns (auth, db, cache) are in foundation layer\n3. **Event-Driven Communication**: Modules communicate via domain events, not direct imports\n4. **Future Decomposition**: Each module can become a microservice by extracting it with its own database\n\n### Multi-Tenancy Strategy\n\n- **Shared Database, Tenant Column**: All tables have `workspace_id` column\n- **Query Scoping**: All queries automatically filtered by workspace context\n- **Row-Level Security**: PostgreSQL RLS as defense-in-depth\n\n```sql\n-- Every table includes workspace_id\nCREATE TABLE tasks (\n  id UUID PRIMARY KEY,\n  workspace_id UUID NOT NULL REFERENCES workspaces(id),\n  title TEXT NOT NULL,\n  -- ...\n);\n\n-- RLS policy\nALTER TABLE tasks ENABLE ROW LEVEL SECURITY;\nCREATE POLICY workspace_isolation ON tasks\n  USING (workspace_id = current_setting('app.workspace_id')::UUID);\n```\n\n### Real-Time Architecture\n\n```\n┌─────────────┐     WebSocket      ┌─────────────┐\n│   Client 1  │◄──────────────────►│             │\n└─────────────┘                    │             │\n                                   │   Server    │\n┌─────────────┐     WebSocket      │   Instance  │\n│   Client 2  │◄──────────────────►│      1      │\n└─────────────┘                    │             │\n                                   └──────┬──────┘\n                                          │\n                                   Redis Pub/Sub\n                                          │\n                                   ┌──────┴──────┐\n┌─────────────┐     WebSocket      │   Server    │\n│   Client 3  │◄──────────────────►│   Instance  │\n└─────────────┘                    │      2      │\n                                   └─────────────┘\n```\n\n- **Room-Based Subscriptions**: Clients subscribe to specific board rooms\n- **Redis Pub/Sub**: Enables broadcast across multiple server instances\n- **Presence Tracking**: Know who's viewing which board\n\n### API Design\n\n- **REST API**: CRUD operations, suitable for mobile apps\n- **Resource-Oriented**: `/api/workspaces/:id/boards/:boardId/tasks`\n- **Versioning**: URL path versioning (`/api/v1/...`)\n- **Pagination**: Cursor-based for lists\n\n### Security Layers\n\n1. **Authentication**: Google OAuth → JWT token\n2. **Authorization**: RBAC (Owner, Admin, Member roles)\n3. **Workspace Guard**: Verify membership before any operation\n4. **Rate Limiting**: Per-user and per-workspace limits\n5. **Input Validation**: Zod schemas on all endpoints\n\n## Consequences\n\n### Positive\n\n- **Rapid Development**: Single codebase, simple deployment\n- **Type Safety**: TypeScript end-to-end reduces bugs\n- **Real-Time Built-In**: WebSocket + Redis ready from day one\n- **Clear Boundaries**: Module structure guides team organization\n- **Future Flexibility**: Can extract modules to microservices when needed\n\n### Negative\n\n- **Scaling Limits**: Single process limits (mitigated by horizontal scaling with Redis)\n- **Deployment Coupling**: All modules deploy together\n- **Shared Database**: Schema changes affect all modules\n\n### Risks & Mitigations\n\n| Risk | Mitigation |\n|------|------------|\n| Module coupling creeping in | Enforce module boundaries via lint rules |\n| Real-time scaling issues | Redis pub/sub enables horizontal scaling |\n| Multi-tenant data leaks | RLS + automated testing of tenant isolation |\n| OAuth provider dependency | Can add more providers later |\n\n## Implementation Phases\n\n### Phase 1: Foundation (Week 1-2)\n- [ ] Project setup (TypeScript, ESLint, Prettier)\n- [ ] Foundation layer (HTTP, Auth, DB, Cache)\n- [ ] Google OAuth integration\n- [ ] Basic user model\n\n### Phase 2: Core Features (Week 3-4)\n- [ ] Workspace module\n- [ ] Board module\n- [ ] Task module (CRUD)\n- [ ] Basic frontend with auth\n\n### Phase 3: Real-Time (Week 5-6)\n- [ ] WebSocket server\n- [ ] Board subscriptions\n- [ ] Live task updates\n- [ ] Presence indicators\n\n### Phase 4: Polish (Week 7-8)\n- [ ] Task comments\n- [ ] Member invitations\n- [ ] Notifications\n- [ ] Performance optimization\n\n## Related Documents\n\n- [c3-context.md](../c3-context.md) - System boundary and actors\n- [c3-containers.md](../c3-containers.md) - Deployable units\n- [c3-components.md](../c3-components.md) - Internal structure\n\n## References\n\n- [ref:module-structure](../refs/module-structure.md) - Standard module layout\n- [ref:repository-pattern](../refs/repository-pattern.md) - Data access pattern\n- [ref:auth-middleware](../refs/auth-middleware.md) - Authentication setup\n- [ref:websocket-handler](../refs/websocket-handler.md) - WebSocket patterns\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:29:54.960Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "in_progress",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:29:54.975Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "in_progress",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "in_progress",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "pending",
            "activeForm": "Creating C3 refs"
          }
        ],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "in_progress",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:30:16.576Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/module-structure.md",
        "content": "# Reference: Module Structure\n\n> Standard layout for feature modules in the modular monolith\n\n## Pattern\n\nEach feature module follows a consistent structure separating concerns:\n\n```\nsrc/modules/{module-name}/\n├── {module}.controller.ts   # HTTP route handlers\n├── {module}.service.ts      # Business logic\n├── {module}.repository.ts   # Data access\n├── {module}.schema.ts       # Zod validation schemas\n├── {module}.types.ts        # TypeScript interfaces\n├── {module}.events.ts       # Domain events (optional)\n└── index.ts                 # Public exports (barrel file)\n```\n\n## Layer Responsibilities\n\n### Controller (`*.controller.ts`)\n\n- HTTP request/response handling\n- Input validation (call schema)\n- Call service methods\n- Return appropriate HTTP status codes\n\n```typescript\n// task.controller.ts\nimport { Router } from 'express';\nimport { authenticate, authorizeWorkspace } from '@/foundation/auth';\nimport { TaskService } from './task.service';\nimport { createTaskSchema, updateTaskSchema } from './task.schema';\n\nconst router = Router();\nconst taskService = new TaskService();\n\nrouter.post(\n  '/tasks',\n  authenticate,\n  authorizeWorkspace,\n  async (req, res, next) => {\n    try {\n      const data = createTaskSchema.parse(req.body);\n      const task = await taskService.create(data, req.user);\n      res.status(201).json(task);\n    } catch (error) {\n      next(error);\n    }\n  }\n);\n\nexport const taskController = router;\n```\n\n### Service (`*.service.ts`)\n\n- Business logic and rules\n- Orchestrate repository calls\n- Emit domain events\n- Transaction management\n\n```typescript\n// task.service.ts\nimport { TaskRepository } from './task.repository';\nimport { eventBus } from '@/foundation/events';\nimport { CreateTaskInput, Task } from './task.types';\n\nexport class TaskService {\n  constructor(private repo = new TaskRepository()) {}\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    // Business logic\n    const task = await this.repo.create({\n      ...input,\n      workspaceId: user.workspaceId,\n      createdBy: user.id,\n    });\n\n    // Emit domain event\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n### Repository (`*.repository.ts`)\n\n- Data access only (no business logic)\n- SQL queries via Kysely\n- Return domain objects\n\n```typescript\n// task.repository.ts\nimport { db } from '@/foundation/db';\nimport { Task, CreateTaskRow } from './task.types';\n\nexport class TaskRepository {\n  async create(data: CreateTaskRow): Promise<Task> {\n    return db\n      .insertInto('tasks')\n      .values(data)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  async findById(id: string, workspaceId: string): Promise<Task | null> {\n    return db\n      .selectFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', workspaceId)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n}\n```\n\n### Schema (`*.schema.ts`)\n\n- Zod validation schemas\n- Request body validation\n- Query parameter validation\n\n```typescript\n// task.schema.ts\nimport { z } from 'zod';\n\nexport const createTaskSchema = z.object({\n  title: z.string().min(1).max(200),\n  description: z.string().max(2000).optional(),\n  columnId: z.string().uuid(),\n  assigneeId: z.string().uuid().optional(),\n  dueDate: z.string().datetime().optional(),\n});\n\nexport const updateTaskSchema = createTaskSchema.partial();\n\nexport type CreateTaskInput = z.infer<typeof createTaskSchema>;\n```\n\n### Types (`*.types.ts`)\n\n- Domain interfaces\n- DTO types\n- Enums\n\n```typescript\n// task.types.ts\nexport interface Task {\n  id: string;\n  workspaceId: string;\n  boardId: string;\n  columnId: string;\n  title: string;\n  description: string | null;\n  assigneeId: string | null;\n  dueDate: Date | null;\n  position: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateTaskRow extends Omit<Task, 'id' | 'createdAt' | 'updatedAt'> {}\n```\n\n### Index (`index.ts`)\n\n- Public exports only\n- Controls module API surface\n\n```typescript\n// index.ts\nexport { taskController } from './task.controller';\nexport { TaskService } from './task.service';\nexport type { Task, CreateTaskInput } from './task.types';\n```\n\n## Module Dependencies\n\nModules should:\n- ✅ Import from foundation layer\n- ✅ Import types from other modules\n- ✅ Communicate via domain events\n- ❌ Never import services from other modules directly\n\n```typescript\n// ✅ Correct: Import type only\nimport type { User } from '@/modules/user';\n\n// ✅ Correct: Use events for cross-module communication\neventBus.emit('task.assigned', { taskId, userId });\n\n// ❌ Wrong: Direct service import\nimport { UserService } from '@/modules/user';\n```\n\n## Used By\n\n- [c3-1.5: Workspace Module](../c3-components.md#c3-15-workspace-module)\n- [c3-1.6: Board Module](../c3-components.md#c3-16-board-module)\n- [c3-1.7: Task Module](../c3-components.md#c3-17-task-module)\n- [c3-1.9: User Module](../c3-components.md#c3-19-user-module)\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:30:16.592Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/module-structure.md",
        "content": "# Reference: Module Structure\n\n> Standard layout for feature modules in the modular monolith\n\n## Pattern\n\nEach feature module follows a consistent structure separating concerns:\n\n```\nsrc/modules/{module-name}/\n├── {module}.controller.ts   # HTTP route handlers\n├── {module}.service.ts      # Business logic\n├── {module}.repository.ts   # Data access\n├── {module}.schema.ts       # Zod validation schemas\n├── {module}.types.ts        # TypeScript interfaces\n├── {module}.events.ts       # Domain events (optional)\n└── index.ts                 # Public exports (barrel file)\n```\n\n## Layer Responsibilities\n\n### Controller (`*.controller.ts`)\n\n- HTTP request/response handling\n- Input validation (call schema)\n- Call service methods\n- Return appropriate HTTP status codes\n\n```typescript\n// task.controller.ts\nimport { Router } from 'express';\nimport { authenticate, authorizeWorkspace } from '@/foundation/auth';\nimport { TaskService } from './task.service';\nimport { createTaskSchema, updateTaskSchema } from './task.schema';\n\nconst router = Router();\nconst taskService = new TaskService();\n\nrouter.post(\n  '/tasks',\n  authenticate,\n  authorizeWorkspace,\n  async (req, res, next) => {\n    try {\n      const data = createTaskSchema.parse(req.body);\n      const task = await taskService.create(data, req.user);\n      res.status(201).json(task);\n    } catch (error) {\n      next(error);\n    }\n  }\n);\n\nexport const taskController = router;\n```\n\n### Service (`*.service.ts`)\n\n- Business logic and rules\n- Orchestrate repository calls\n- Emit domain events\n- Transaction management\n\n```typescript\n// task.service.ts\nimport { TaskRepository } from './task.repository';\nimport { eventBus } from '@/foundation/events';\nimport { CreateTaskInput, Task } from './task.types';\n\nexport class TaskService {\n  constructor(private repo = new TaskRepository()) {}\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    // Business logic\n    const task = await this.repo.create({\n      ...input,\n      workspaceId: user.workspaceId,\n      createdBy: user.id,\n    });\n\n    // Emit domain event\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n### Repository (`*.repository.ts`)\n\n- Data access only (no business logic)\n- SQL queries via Kysely\n- Return domain objects\n\n```typescript\n// task.repository.ts\nimport { db } from '@/foundation/db';\nimport { Task, CreateTaskRow } from './task.types';\n\nexport class TaskRepository {\n  async create(data: CreateTaskRow): Promise<Task> {\n    return db\n      .insertInto('tasks')\n      .values(data)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  async findById(id: string, workspaceId: string): Promise<Task | null> {\n    return db\n      .selectFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', workspaceId)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n}\n```\n\n### Schema (`*.schema.ts`)\n\n- Zod validation schemas\n- Request body validation\n- Query parameter validation\n\n```typescript\n// task.schema.ts\nimport { z } from 'zod';\n\nexport const createTaskSchema = z.object({\n  title: z.string().min(1).max(200),\n  description: z.string().max(2000).optional(),\n  columnId: z.string().uuid(),\n  assigneeId: z.string().uuid().optional(),\n  dueDate: z.string().datetime().optional(),\n});\n\nexport const updateTaskSchema = createTaskSchema.partial();\n\nexport type CreateTaskInput = z.infer<typeof createTaskSchema>;\n```\n\n### Types (`*.types.ts`)\n\n- Domain interfaces\n- DTO types\n- Enums\n\n```typescript\n// task.types.ts\nexport interface Task {\n  id: string;\n  workspaceId: string;\n  boardId: string;\n  columnId: string;\n  title: string;\n  description: string | null;\n  assigneeId: string | null;\n  dueDate: Date | null;\n  position: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateTaskRow extends Omit<Task, 'id' | 'createdAt' | 'updatedAt'> {}\n```\n\n### Index (`index.ts`)\n\n- Public exports only\n- Controls module API surface\n\n```typescript\n// index.ts\nexport { taskController } from './task.controller';\nexport { TaskService } from './task.service';\nexport type { Task, CreateTaskInput } from './task.types';\n```\n\n## Module Dependencies\n\nModules should:\n- ✅ Import from foundation layer\n- ✅ Import types from other modules\n- ✅ Communicate via domain events\n- ❌ Never import services from other modules directly\n\n```typescript\n// ✅ Correct: Import type only\nimport type { User } from '@/modules/user';\n\n// ✅ Correct: Use events for cross-module communication\neventBus.emit('task.assigned', { taskId, userId });\n\n// ❌ Wrong: Direct service import\nimport { UserService } from '@/modules/user';\n```\n\n## Used By\n\n- [c3-1.5: Workspace Module](../c3-components.md#c3-15-workspace-module)\n- [c3-1.6: Board Module](../c3-components.md#c3-16-board-module)\n- [c3-1.7: Task Module](../c3-components.md#c3-17-task-module)\n- [c3-1.9: User Module](../c3-components.md#c3-19-user-module)\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/module-structure.md",
        "content": "# Reference: Module Structure\n\n> Standard layout for feature modules in the modular monolith\n\n## Pattern\n\nEach feature module follows a consistent structure separating concerns:\n\n```\nsrc/modules/{module-name}/\n├── {module}.controller.ts   # HTTP route handlers\n├── {module}.service.ts      # Business logic\n├── {module}.repository.ts   # Data access\n├── {module}.schema.ts       # Zod validation schemas\n├── {module}.types.ts        # TypeScript interfaces\n├── {module}.events.ts       # Domain events (optional)\n└── index.ts                 # Public exports (barrel file)\n```\n\n## Layer Responsibilities\n\n### Controller (`*.controller.ts`)\n\n- HTTP request/response handling\n- Input validation (call schema)\n- Call service methods\n- Return appropriate HTTP status codes\n\n```typescript\n// task.controller.ts\nimport { Router } from 'express';\nimport { authenticate, authorizeWorkspace } from '@/foundation/auth';\nimport { TaskService } from './task.service';\nimport { createTaskSchema, updateTaskSchema } from './task.schema';\n\nconst router = Router();\nconst taskService = new TaskService();\n\nrouter.post(\n  '/tasks',\n  authenticate,\n  authorizeWorkspace,\n  async (req, res, next) => {\n    try {\n      const data = createTaskSchema.parse(req.body);\n      const task = await taskService.create(data, req.user);\n      res.status(201).json(task);\n    } catch (error) {\n      next(error);\n    }\n  }\n);\n\nexport const taskController = router;\n```\n\n### Service (`*.service.ts`)\n\n- Business logic and rules\n- Orchestrate repository calls\n- Emit domain events\n- Transaction management\n\n```typescript\n// task.service.ts\nimport { TaskRepository } from './task.repository';\nimport { eventBus } from '@/foundation/events';\nimport { CreateTaskInput, Task } from './task.types';\n\nexport class TaskService {\n  constructor(private repo = new TaskRepository()) {}\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    // Business logic\n    const task = await this.repo.create({\n      ...input,\n      workspaceId: user.workspaceId,\n      createdBy: user.id,\n    });\n\n    // Emit domain event\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n### Repository (`*.repository.ts`)\n\n- Data access only (no business logic)\n- SQL queries via Kysely\n- Return domain objects\n\n```typescript\n// task.repository.ts\nimport { db } from '@/foundation/db';\nimport { Task, CreateTaskRow } from './task.types';\n\nexport class TaskRepository {\n  async create(data: CreateTaskRow): Promise<Task> {\n    return db\n      .insertInto('tasks')\n      .values(data)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  async findById(id: string, workspaceId: string): Promise<Task | null> {\n    return db\n      .selectFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', workspaceId)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n}\n```\n\n### Schema (`*.schema.ts`)\n\n- Zod validation schemas\n- Request body validation\n- Query parameter validation\n\n```typescript\n// task.schema.ts\nimport { z } from 'zod';\n\nexport const createTaskSchema = z.object({\n  title: z.string().min(1).max(200),\n  description: z.string().max(2000).optional(),\n  columnId: z.string().uuid(),\n  assigneeId: z.string().uuid().optional(),\n  dueDate: z.string().datetime().optional(),\n});\n\nexport const updateTaskSchema = createTaskSchema.partial();\n\nexport type CreateTaskInput = z.infer<typeof createTaskSchema>;\n```\n\n### Types (`*.types.ts`)\n\n- Domain interfaces\n- DTO types\n- Enums\n\n```typescript\n// task.types.ts\nexport interface Task {\n  id: string;\n  workspaceId: string;\n  boardId: string;\n  columnId: string;\n  title: string;\n  description: string | null;\n  assigneeId: string | null;\n  dueDate: Date | null;\n  position: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateTaskRow extends Omit<Task, 'id' | 'createdAt' | 'updatedAt'> {}\n```\n\n### Index (`index.ts`)\n\n- Public exports only\n- Controls module API surface\n\n```typescript\n// index.ts\nexport { taskController } from './task.controller';\nexport { TaskService } from './task.service';\nexport type { Task, CreateTaskInput } from './task.types';\n```\n\n## Module Dependencies\n\nModules should:\n- ✅ Import from foundation layer\n- ✅ Import types from other modules\n- ✅ Communicate via domain events\n- ❌ Never import services from other modules directly\n\n```typescript\n// ✅ Correct: Import type only\nimport type { User } from '@/modules/user';\n\n// ✅ Correct: Use events for cross-module communication\neventBus.emit('task.assigned', { taskId, userId });\n\n// ❌ Wrong: Direct service import\nimport { UserService } from '@/modules/user';\n```\n\n## Used By\n\n- [c3-1.5: Workspace Module](../c3-components.md#c3-15-workspace-module)\n- [c3-1.6: Board Module](../c3-components.md#c3-16-board-module)\n- [c3-1.7: Task Module](../c3-components.md#c3-17-task-module)\n- [c3-1.9: User Module](../c3-components.md#c3-19-user-module)\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:30:39.222Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/auth-middleware.md",
        "content": "# Reference: Auth Middleware\n\n> Authentication and authorization patterns for the API\n\n## Overview\n\nThree-layer security model:\n\n1. **authenticate**: Verify JWT token, populate `req.user`\n2. **authorizeWorkspace**: Verify user belongs to workspace\n3. **authorizeRole**: Check user has required role\n\n## Middleware Chain\n\n```\nRequest → authenticate → authorizeWorkspace → authorizeRole → Controller\n             ↓                  ↓                   ↓\n        401 Unauthorized   403 Forbidden      403 Forbidden\n```\n\n## Implementation\n\n### authenticate\n\nExtracts and validates JWT from Authorization header.\n\n```typescript\n// src/foundation/auth/middleware/authenticate.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { verifyToken } from '../tokens';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const header = req.headers.authorization;\n    if (!header?.startsWith('Bearer ')) {\n      throw new AppError('Missing authorization header', 401);\n    }\n\n    const token = header.slice(7);\n    const payload = await verifyToken(token);\n\n    req.user = {\n      id: payload.sub,\n      email: payload.email,\n    };\n\n    next();\n  } catch (error) {\n    next(new AppError('Invalid or expired token', 401));\n  }\n}\n```\n\n### authorizeWorkspace\n\nVerifies user is a member of the requested workspace.\n\n```typescript\n// src/foundation/auth/middleware/workspace.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { db } from '@/foundation/db';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authorizeWorkspace(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    // Workspace ID from route param or header\n    const workspaceId =\n      req.params.workspaceId ||\n      req.headers['x-workspace-id'] as string;\n\n    if (!workspaceId) {\n      throw new AppError('Workspace ID required', 400);\n    }\n\n    // Check membership\n    const membership = await db\n      .selectFrom('workspace_members')\n      .where('workspace_id', '=', workspaceId)\n      .where('user_id', '=', req.user.id)\n      .select(['role'])\n      .executeTakeFirst();\n\n    if (!membership) {\n      throw new AppError('Not a member of this workspace', 403);\n    }\n\n    // Attach to request\n    req.user.workspaceId = workspaceId;\n    req.user.role = membership.role;\n\n    // Set for RLS\n    await db.executeQuery(\n      sql`SELECT set_config('app.workspace_id', ${workspaceId}, true)`\n    );\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n### authorizeRole\n\nFactory function for role-based access control.\n\n```typescript\n// src/foundation/auth/middleware/authorize.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '@/foundation/http/errors';\n\ntype WorkspaceRole = 'owner' | 'admin' | 'member';\n\nconst roleHierarchy: Record<WorkspaceRole, number> = {\n  owner: 3,\n  admin: 2,\n  member: 1,\n};\n\nexport function authorizeRole(minRole: WorkspaceRole) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const userRoleLevel = roleHierarchy[req.user.role];\n    const requiredLevel = roleHierarchy[minRole];\n\n    if (userRoleLevel < requiredLevel) {\n      return next(new AppError(\n        `Requires ${minRole} role or higher`,\n        403\n      ));\n    }\n\n    next();\n  };\n}\n```\n\n## Usage Examples\n\n```typescript\n// Public route (no auth)\nrouter.get('/health', (req, res) => res.json({ ok: true }));\n\n// Authenticated route\nrouter.get(\n  '/users/me',\n  authenticate,\n  getUserProfile\n);\n\n// Workspace-scoped route\nrouter.get(\n  '/workspaces/:workspaceId/boards',\n  authenticate,\n  authorizeWorkspace,\n  listBoards\n);\n\n// Admin-only route\nrouter.delete(\n  '/workspaces/:workspaceId/members/:userId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('admin'),\n  removeMember\n);\n\n// Owner-only route\nrouter.delete(\n  '/workspaces/:workspaceId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('owner'),\n  deleteWorkspace\n);\n```\n\n## Request Type Extension\n\n```typescript\n// src/foundation/auth/types.ts\ndeclare global {\n  namespace Express {\n    interface Request {\n      user: {\n        id: string;\n        email: string;\n        workspaceId?: string;\n        role?: WorkspaceRole;\n      };\n    }\n  }\n}\n```\n\n## Google OAuth Strategy\n\n```typescript\n// src/foundation/auth/strategies/google.ts\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { UserRepository } from '@/modules/user';\n\nconst userRepo = new UserRepository();\n\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID!,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    callbackURL: '/api/auth/google/callback',\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    try {\n      // Find or create user\n      let user = await userRepo.findByGoogleId(profile.id);\n\n      if (!user) {\n        user = await userRepo.create({\n          email: profile.emails![0].value,\n          name: profile.displayName,\n          googleId: profile.id,\n          avatarUrl: profile.photos?.[0]?.value,\n        });\n      }\n\n      done(null, user);\n    } catch (error) {\n      done(error);\n    }\n  }\n));\n```\n\n## Used By\n\n- [c3-1.1: Auth Guard](../c3-components.md#c3-11-auth-guard)\n- All feature module controllers\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:30:39.251Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/auth-middleware.md",
        "content": "# Reference: Auth Middleware\n\n> Authentication and authorization patterns for the API\n\n## Overview\n\nThree-layer security model:\n\n1. **authenticate**: Verify JWT token, populate `req.user`\n2. **authorizeWorkspace**: Verify user belongs to workspace\n3. **authorizeRole**: Check user has required role\n\n## Middleware Chain\n\n```\nRequest → authenticate → authorizeWorkspace → authorizeRole → Controller\n             ↓                  ↓                   ↓\n        401 Unauthorized   403 Forbidden      403 Forbidden\n```\n\n## Implementation\n\n### authenticate\n\nExtracts and validates JWT from Authorization header.\n\n```typescript\n// src/foundation/auth/middleware/authenticate.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { verifyToken } from '../tokens';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const header = req.headers.authorization;\n    if (!header?.startsWith('Bearer ')) {\n      throw new AppError('Missing authorization header', 401);\n    }\n\n    const token = header.slice(7);\n    const payload = await verifyToken(token);\n\n    req.user = {\n      id: payload.sub,\n      email: payload.email,\n    };\n\n    next();\n  } catch (error) {\n    next(new AppError('Invalid or expired token', 401));\n  }\n}\n```\n\n### authorizeWorkspace\n\nVerifies user is a member of the requested workspace.\n\n```typescript\n// src/foundation/auth/middleware/workspace.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { db } from '@/foundation/db';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authorizeWorkspace(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    // Workspace ID from route param or header\n    const workspaceId =\n      req.params.workspaceId ||\n      req.headers['x-workspace-id'] as string;\n\n    if (!workspaceId) {\n      throw new AppError('Workspace ID required', 400);\n    }\n\n    // Check membership\n    const membership = await db\n      .selectFrom('workspace_members')\n      .where('workspace_id', '=', workspaceId)\n      .where('user_id', '=', req.user.id)\n      .select(['role'])\n      .executeTakeFirst();\n\n    if (!membership) {\n      throw new AppError('Not a member of this workspace', 403);\n    }\n\n    // Attach to request\n    req.user.workspaceId = workspaceId;\n    req.user.role = membership.role;\n\n    // Set for RLS\n    await db.executeQuery(\n      sql`SELECT set_config('app.workspace_id', ${workspaceId}, true)`\n    );\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n### authorizeRole\n\nFactory function for role-based access control.\n\n```typescript\n// src/foundation/auth/middleware/authorize.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '@/foundation/http/errors';\n\ntype WorkspaceRole = 'owner' | 'admin' | 'member';\n\nconst roleHierarchy: Record<WorkspaceRole, number> = {\n  owner: 3,\n  admin: 2,\n  member: 1,\n};\n\nexport function authorizeRole(minRole: WorkspaceRole) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const userRoleLevel = roleHierarchy[req.user.role];\n    const requiredLevel = roleHierarchy[minRole];\n\n    if (userRoleLevel < requiredLevel) {\n      return next(new AppError(\n        `Requires ${minRole} role or higher`,\n        403\n      ));\n    }\n\n    next();\n  };\n}\n```\n\n## Usage Examples\n\n```typescript\n// Public route (no auth)\nrouter.get('/health', (req, res) => res.json({ ok: true }));\n\n// Authenticated route\nrouter.get(\n  '/users/me',\n  authenticate,\n  getUserProfile\n);\n\n// Workspace-scoped route\nrouter.get(\n  '/workspaces/:workspaceId/boards',\n  authenticate,\n  authorizeWorkspace,\n  listBoards\n);\n\n// Admin-only route\nrouter.delete(\n  '/workspaces/:workspaceId/members/:userId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('admin'),\n  removeMember\n);\n\n// Owner-only route\nrouter.delete(\n  '/workspaces/:workspaceId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('owner'),\n  deleteWorkspace\n);\n```\n\n## Request Type Extension\n\n```typescript\n// src/foundation/auth/types.ts\ndeclare global {\n  namespace Express {\n    interface Request {\n      user: {\n        id: string;\n        email: string;\n        workspaceId?: string;\n        role?: WorkspaceRole;\n      };\n    }\n  }\n}\n```\n\n## Google OAuth Strategy\n\n```typescript\n// src/foundation/auth/strategies/google.ts\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { UserRepository } from '@/modules/user';\n\nconst userRepo = new UserRepository();\n\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID!,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    callbackURL: '/api/auth/google/callback',\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    try {\n      // Find or create user\n      let user = await userRepo.findByGoogleId(profile.id);\n\n      if (!user) {\n        user = await userRepo.create({\n          email: profile.emails![0].value,\n          name: profile.displayName,\n          googleId: profile.id,\n          avatarUrl: profile.photos?.[0]?.value,\n        });\n      }\n\n      done(null, user);\n    } catch (error) {\n      done(error);\n    }\n  }\n));\n```\n\n## Used By\n\n- [c3-1.1: Auth Guard](../c3-components.md#c3-11-auth-guard)\n- All feature module controllers\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/auth-middleware.md",
        "content": "# Reference: Auth Middleware\n\n> Authentication and authorization patterns for the API\n\n## Overview\n\nThree-layer security model:\n\n1. **authenticate**: Verify JWT token, populate `req.user`\n2. **authorizeWorkspace**: Verify user belongs to workspace\n3. **authorizeRole**: Check user has required role\n\n## Middleware Chain\n\n```\nRequest → authenticate → authorizeWorkspace → authorizeRole → Controller\n             ↓                  ↓                   ↓\n        401 Unauthorized   403 Forbidden      403 Forbidden\n```\n\n## Implementation\n\n### authenticate\n\nExtracts and validates JWT from Authorization header.\n\n```typescript\n// src/foundation/auth/middleware/authenticate.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { verifyToken } from '../tokens';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const header = req.headers.authorization;\n    if (!header?.startsWith('Bearer ')) {\n      throw new AppError('Missing authorization header', 401);\n    }\n\n    const token = header.slice(7);\n    const payload = await verifyToken(token);\n\n    req.user = {\n      id: payload.sub,\n      email: payload.email,\n    };\n\n    next();\n  } catch (error) {\n    next(new AppError('Invalid or expired token', 401));\n  }\n}\n```\n\n### authorizeWorkspace\n\nVerifies user is a member of the requested workspace.\n\n```typescript\n// src/foundation/auth/middleware/workspace.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { db } from '@/foundation/db';\nimport { AppError } from '@/foundation/http/errors';\n\nexport async function authorizeWorkspace(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    // Workspace ID from route param or header\n    const workspaceId =\n      req.params.workspaceId ||\n      req.headers['x-workspace-id'] as string;\n\n    if (!workspaceId) {\n      throw new AppError('Workspace ID required', 400);\n    }\n\n    // Check membership\n    const membership = await db\n      .selectFrom('workspace_members')\n      .where('workspace_id', '=', workspaceId)\n      .where('user_id', '=', req.user.id)\n      .select(['role'])\n      .executeTakeFirst();\n\n    if (!membership) {\n      throw new AppError('Not a member of this workspace', 403);\n    }\n\n    // Attach to request\n    req.user.workspaceId = workspaceId;\n    req.user.role = membership.role;\n\n    // Set for RLS\n    await db.executeQuery(\n      sql`SELECT set_config('app.workspace_id', ${workspaceId}, true)`\n    );\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n### authorizeRole\n\nFactory function for role-based access control.\n\n```typescript\n// src/foundation/auth/middleware/authorize.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '@/foundation/http/errors';\n\ntype WorkspaceRole = 'owner' | 'admin' | 'member';\n\nconst roleHierarchy: Record<WorkspaceRole, number> = {\n  owner: 3,\n  admin: 2,\n  member: 1,\n};\n\nexport function authorizeRole(minRole: WorkspaceRole) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const userRoleLevel = roleHierarchy[req.user.role];\n    const requiredLevel = roleHierarchy[minRole];\n\n    if (userRoleLevel < requiredLevel) {\n      return next(new AppError(\n        `Requires ${minRole} role or higher`,\n        403\n      ));\n    }\n\n    next();\n  };\n}\n```\n\n## Usage Examples\n\n```typescript\n// Public route (no auth)\nrouter.get('/health', (req, res) => res.json({ ok: true }));\n\n// Authenticated route\nrouter.get(\n  '/users/me',\n  authenticate,\n  getUserProfile\n);\n\n// Workspace-scoped route\nrouter.get(\n  '/workspaces/:workspaceId/boards',\n  authenticate,\n  authorizeWorkspace,\n  listBoards\n);\n\n// Admin-only route\nrouter.delete(\n  '/workspaces/:workspaceId/members/:userId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('admin'),\n  removeMember\n);\n\n// Owner-only route\nrouter.delete(\n  '/workspaces/:workspaceId',\n  authenticate,\n  authorizeWorkspace,\n  authorizeRole('owner'),\n  deleteWorkspace\n);\n```\n\n## Request Type Extension\n\n```typescript\n// src/foundation/auth/types.ts\ndeclare global {\n  namespace Express {\n    interface Request {\n      user: {\n        id: string;\n        email: string;\n        workspaceId?: string;\n        role?: WorkspaceRole;\n      };\n    }\n  }\n}\n```\n\n## Google OAuth Strategy\n\n```typescript\n// src/foundation/auth/strategies/google.ts\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { UserRepository } from '@/modules/user';\n\nconst userRepo = new UserRepository();\n\npassport.use(new GoogleStrategy({\n    clientID: process.env.GOOGLE_CLIENT_ID!,\n    clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    callbackURL: '/api/auth/google/callback',\n  },\n  async (accessToken, refreshToken, profile, done) => {\n    try {\n      // Find or create user\n      let user = await userRepo.findByGoogleId(profile.id);\n\n      if (!user) {\n        user = await userRepo.create({\n          email: profile.emails![0].value,\n          name: profile.displayName,\n          googleId: profile.id,\n          avatarUrl: profile.photos?.[0]?.value,\n        });\n      }\n\n      done(null, user);\n    } catch (error) {\n      done(error);\n    }\n  }\n));\n```\n\n## Used By\n\n- [c3-1.1: Auth Guard](../c3-components.md#c3-11-auth-guard)\n- All feature module controllers\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:31:03.674Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/repository-pattern.md",
        "content": "# Reference: Repository Pattern\n\n> Data access abstraction with Kysely query builder\n\n## Overview\n\nRepositories encapsulate database access, providing:\n- Type-safe queries\n- Multi-tenant scoping\n- Clean separation from business logic\n\n## Base Repository\n\n```typescript\n// src/foundation/db/base-repository.ts\nimport { db, Transaction } from './client';\nimport { Kysely } from 'kysely';\n\nexport abstract class BaseRepository<T> {\n  protected db: Kysely<Database>;\n\n  constructor(trx?: Transaction) {\n    this.db = trx ?? db;\n  }\n\n  /**\n   * Run operations in a transaction\n   */\n  static async transaction<R>(\n    fn: (trx: Transaction) => Promise<R>\n  ): Promise<R> {\n    return db.transaction().execute(fn);\n  }\n}\n```\n\n## Tenant-Scoped Repository\n\n```typescript\n// src/foundation/db/scopes/tenant-repository.ts\nimport { BaseRepository } from '../base-repository';\n\nexport abstract class TenantRepository<T> extends BaseRepository<T> {\n  protected abstract tableName: string;\n  protected workspaceId: string;\n\n  constructor(workspaceId: string, trx?: Transaction) {\n    super(trx);\n    this.workspaceId = workspaceId;\n  }\n\n  /**\n   * Automatically scope all queries to workspace\n   */\n  protected scoped() {\n    return this.db\n      .selectFrom(this.tableName as any)\n      .where('workspace_id', '=', this.workspaceId);\n  }\n}\n```\n\n## Example Implementation\n\n```typescript\n// src/modules/task/task.repository.ts\nimport { TenantRepository } from '@/foundation/db/scopes/tenant-repository';\nimport { Task, CreateTaskData, UpdateTaskData } from './task.types';\n\nexport class TaskRepository extends TenantRepository<Task> {\n  protected tableName = 'tasks';\n\n  /**\n   * Create a new task\n   */\n  async create(data: CreateTaskData): Promise<Task> {\n    // Get max position in column\n    const maxPos = await this.scoped()\n      .where('column_id', '=', data.columnId)\n      .select(({ fn }) => fn.max('position').as('maxPosition'))\n      .executeTakeFirst();\n\n    return this.db\n      .insertInto('tasks')\n      .values({\n        ...data,\n        workspace_id: this.workspaceId,\n        position: (maxPos?.maxPosition ?? 0) + 1,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Find task by ID (scoped to workspace)\n   */\n  async findById(id: string): Promise<Task | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  /**\n   * List tasks for a board\n   */\n  async findByBoard(boardId: string): Promise<Task[]> {\n    return this.scoped()\n      .where('board_id', '=', boardId)\n      .orderBy('column_id')\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  /**\n   * Update a task\n   */\n  async update(id: string, data: UpdateTaskData): Promise<Task> {\n    return this.db\n      .updateTable('tasks')\n      .set({\n        ...data,\n        updated_at: new Date(),\n      })\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Move task to new column and position\n   */\n  async move(id: string, columnId: string, position: number): Promise<Task> {\n    return this.db.transaction().execute(async (trx) => {\n      // Shift tasks in target column\n      await trx\n        .updateTable('tasks')\n        .set({ position: sql`position + 1` })\n        .where('column_id', '=', columnId)\n        .where('workspace_id', '=', this.workspaceId)\n        .where('position', '>=', position)\n        .execute();\n\n      // Move the task\n      return trx\n        .updateTable('tasks')\n        .set({\n          column_id: columnId,\n          position: position,\n          updated_at: new Date(),\n        })\n        .where('id', '=', id)\n        .where('workspace_id', '=', this.workspaceId)\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n  }\n\n  /**\n   * Delete a task\n   */\n  async delete(id: string): Promise<void> {\n    await this.db\n      .deleteFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .execute();\n  }\n\n  /**\n   * Search tasks\n   */\n  async search(query: string): Promise<Task[]> {\n    return this.scoped()\n      .where(({ or, eb }) => or([\n        eb('title', 'ilike', `%${query}%`),\n        eb('description', 'ilike', `%${query}%`),\n      ]))\n      .orderBy('updated_at', 'desc')\n      .limit(50)\n      .selectAll()\n      .execute();\n  }\n}\n```\n\n## Usage in Service\n\n```typescript\n// src/modules/task/task.service.ts\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const repo = new TaskRepository(user.workspaceId);\n\n    // Validate board belongs to workspace\n    const board = await new BoardRepository(user.workspaceId)\n      .findById(input.boardId);\n\n    if (!board) {\n      throw new AppError('Board not found', 404);\n    }\n\n    const task = await repo.create({\n      ...input,\n      createdBy: user.id,\n    });\n\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n## Database Types Generation\n\n```typescript\n// src/foundation/db/types.ts (generated from schema)\nexport interface Database {\n  users: UserTable;\n  workspaces: WorkspaceTable;\n  workspace_members: WorkspaceMemberTable;\n  boards: BoardTable;\n  columns: ColumnTable;\n  tasks: TaskTable;\n  comments: CommentTable;\n}\n\nexport interface TaskTable {\n  id: Generated<string>;\n  workspace_id: string;\n  board_id: string;\n  column_id: string;\n  title: string;\n  description: string | null;\n  assignee_id: string | null;\n  due_date: Date | null;\n  position: number;\n  created_by: string;\n  created_at: Generated<Date>;\n  updated_at: Generated<Date>;\n}\n\nexport type Task = Selectable<TaskTable>;\nexport type NewTask = Insertable<TaskTable>;\nexport type TaskUpdate = Updateable<TaskTable>;\n```\n\n## Used By\n\n- [c3-1.2: DB Client](../c3-components.md#c3-12-db-client)\n- All feature module repositories\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:31:03.689Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/repository-pattern.md",
        "content": "# Reference: Repository Pattern\n\n> Data access abstraction with Kysely query builder\n\n## Overview\n\nRepositories encapsulate database access, providing:\n- Type-safe queries\n- Multi-tenant scoping\n- Clean separation from business logic\n\n## Base Repository\n\n```typescript\n// src/foundation/db/base-repository.ts\nimport { db, Transaction } from './client';\nimport { Kysely } from 'kysely';\n\nexport abstract class BaseRepository<T> {\n  protected db: Kysely<Database>;\n\n  constructor(trx?: Transaction) {\n    this.db = trx ?? db;\n  }\n\n  /**\n   * Run operations in a transaction\n   */\n  static async transaction<R>(\n    fn: (trx: Transaction) => Promise<R>\n  ): Promise<R> {\n    return db.transaction().execute(fn);\n  }\n}\n```\n\n## Tenant-Scoped Repository\n\n```typescript\n// src/foundation/db/scopes/tenant-repository.ts\nimport { BaseRepository } from '../base-repository';\n\nexport abstract class TenantRepository<T> extends BaseRepository<T> {\n  protected abstract tableName: string;\n  protected workspaceId: string;\n\n  constructor(workspaceId: string, trx?: Transaction) {\n    super(trx);\n    this.workspaceId = workspaceId;\n  }\n\n  /**\n   * Automatically scope all queries to workspace\n   */\n  protected scoped() {\n    return this.db\n      .selectFrom(this.tableName as any)\n      .where('workspace_id', '=', this.workspaceId);\n  }\n}\n```\n\n## Example Implementation\n\n```typescript\n// src/modules/task/task.repository.ts\nimport { TenantRepository } from '@/foundation/db/scopes/tenant-repository';\nimport { Task, CreateTaskData, UpdateTaskData } from './task.types';\n\nexport class TaskRepository extends TenantRepository<Task> {\n  protected tableName = 'tasks';\n\n  /**\n   * Create a new task\n   */\n  async create(data: CreateTaskData): Promise<Task> {\n    // Get max position in column\n    const maxPos = await this.scoped()\n      .where('column_id', '=', data.columnId)\n      .select(({ fn }) => fn.max('position').as('maxPosition'))\n      .executeTakeFirst();\n\n    return this.db\n      .insertInto('tasks')\n      .values({\n        ...data,\n        workspace_id: this.workspaceId,\n        position: (maxPos?.maxPosition ?? 0) + 1,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Find task by ID (scoped to workspace)\n   */\n  async findById(id: string): Promise<Task | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  /**\n   * List tasks for a board\n   */\n  async findByBoard(boardId: string): Promise<Task[]> {\n    return this.scoped()\n      .where('board_id', '=', boardId)\n      .orderBy('column_id')\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  /**\n   * Update a task\n   */\n  async update(id: string, data: UpdateTaskData): Promise<Task> {\n    return this.db\n      .updateTable('tasks')\n      .set({\n        ...data,\n        updated_at: new Date(),\n      })\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Move task to new column and position\n   */\n  async move(id: string, columnId: string, position: number): Promise<Task> {\n    return this.db.transaction().execute(async (trx) => {\n      // Shift tasks in target column\n      await trx\n        .updateTable('tasks')\n        .set({ position: sql`position + 1` })\n        .where('column_id', '=', columnId)\n        .where('workspace_id', '=', this.workspaceId)\n        .where('position', '>=', position)\n        .execute();\n\n      // Move the task\n      return trx\n        .updateTable('tasks')\n        .set({\n          column_id: columnId,\n          position: position,\n          updated_at: new Date(),\n        })\n        .where('id', '=', id)\n        .where('workspace_id', '=', this.workspaceId)\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n  }\n\n  /**\n   * Delete a task\n   */\n  async delete(id: string): Promise<void> {\n    await this.db\n      .deleteFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .execute();\n  }\n\n  /**\n   * Search tasks\n   */\n  async search(query: string): Promise<Task[]> {\n    return this.scoped()\n      .where(({ or, eb }) => or([\n        eb('title', 'ilike', `%${query}%`),\n        eb('description', 'ilike', `%${query}%`),\n      ]))\n      .orderBy('updated_at', 'desc')\n      .limit(50)\n      .selectAll()\n      .execute();\n  }\n}\n```\n\n## Usage in Service\n\n```typescript\n// src/modules/task/task.service.ts\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const repo = new TaskRepository(user.workspaceId);\n\n    // Validate board belongs to workspace\n    const board = await new BoardRepository(user.workspaceId)\n      .findById(input.boardId);\n\n    if (!board) {\n      throw new AppError('Board not found', 404);\n    }\n\n    const task = await repo.create({\n      ...input,\n      createdBy: user.id,\n    });\n\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n## Database Types Generation\n\n```typescript\n// src/foundation/db/types.ts (generated from schema)\nexport interface Database {\n  users: UserTable;\n  workspaces: WorkspaceTable;\n  workspace_members: WorkspaceMemberTable;\n  boards: BoardTable;\n  columns: ColumnTable;\n  tasks: TaskTable;\n  comments: CommentTable;\n}\n\nexport interface TaskTable {\n  id: Generated<string>;\n  workspace_id: string;\n  board_id: string;\n  column_id: string;\n  title: string;\n  description: string | null;\n  assignee_id: string | null;\n  due_date: Date | null;\n  position: number;\n  created_by: string;\n  created_at: Generated<Date>;\n  updated_at: Generated<Date>;\n}\n\nexport type Task = Selectable<TaskTable>;\nexport type NewTask = Insertable<TaskTable>;\nexport type TaskUpdate = Updateable<TaskTable>;\n```\n\n## Used By\n\n- [c3-1.2: DB Client](../c3-components.md#c3-12-db-client)\n- All feature module repositories\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/repository-pattern.md",
        "content": "# Reference: Repository Pattern\n\n> Data access abstraction with Kysely query builder\n\n## Overview\n\nRepositories encapsulate database access, providing:\n- Type-safe queries\n- Multi-tenant scoping\n- Clean separation from business logic\n\n## Base Repository\n\n```typescript\n// src/foundation/db/base-repository.ts\nimport { db, Transaction } from './client';\nimport { Kysely } from 'kysely';\n\nexport abstract class BaseRepository<T> {\n  protected db: Kysely<Database>;\n\n  constructor(trx?: Transaction) {\n    this.db = trx ?? db;\n  }\n\n  /**\n   * Run operations in a transaction\n   */\n  static async transaction<R>(\n    fn: (trx: Transaction) => Promise<R>\n  ): Promise<R> {\n    return db.transaction().execute(fn);\n  }\n}\n```\n\n## Tenant-Scoped Repository\n\n```typescript\n// src/foundation/db/scopes/tenant-repository.ts\nimport { BaseRepository } from '../base-repository';\n\nexport abstract class TenantRepository<T> extends BaseRepository<T> {\n  protected abstract tableName: string;\n  protected workspaceId: string;\n\n  constructor(workspaceId: string, trx?: Transaction) {\n    super(trx);\n    this.workspaceId = workspaceId;\n  }\n\n  /**\n   * Automatically scope all queries to workspace\n   */\n  protected scoped() {\n    return this.db\n      .selectFrom(this.tableName as any)\n      .where('workspace_id', '=', this.workspaceId);\n  }\n}\n```\n\n## Example Implementation\n\n```typescript\n// src/modules/task/task.repository.ts\nimport { TenantRepository } from '@/foundation/db/scopes/tenant-repository';\nimport { Task, CreateTaskData, UpdateTaskData } from './task.types';\n\nexport class TaskRepository extends TenantRepository<Task> {\n  protected tableName = 'tasks';\n\n  /**\n   * Create a new task\n   */\n  async create(data: CreateTaskData): Promise<Task> {\n    // Get max position in column\n    const maxPos = await this.scoped()\n      .where('column_id', '=', data.columnId)\n      .select(({ fn }) => fn.max('position').as('maxPosition'))\n      .executeTakeFirst();\n\n    return this.db\n      .insertInto('tasks')\n      .values({\n        ...data,\n        workspace_id: this.workspaceId,\n        position: (maxPos?.maxPosition ?? 0) + 1,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Find task by ID (scoped to workspace)\n   */\n  async findById(id: string): Promise<Task | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  /**\n   * List tasks for a board\n   */\n  async findByBoard(boardId: string): Promise<Task[]> {\n    return this.scoped()\n      .where('board_id', '=', boardId)\n      .orderBy('column_id')\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  /**\n   * Update a task\n   */\n  async update(id: string, data: UpdateTaskData): Promise<Task> {\n    return this.db\n      .updateTable('tasks')\n      .set({\n        ...data,\n        updated_at: new Date(),\n      })\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n\n  /**\n   * Move task to new column and position\n   */\n  async move(id: string, columnId: string, position: number): Promise<Task> {\n    return this.db.transaction().execute(async (trx) => {\n      // Shift tasks in target column\n      await trx\n        .updateTable('tasks')\n        .set({ position: sql`position + 1` })\n        .where('column_id', '=', columnId)\n        .where('workspace_id', '=', this.workspaceId)\n        .where('position', '>=', position)\n        .execute();\n\n      // Move the task\n      return trx\n        .updateTable('tasks')\n        .set({\n          column_id: columnId,\n          position: position,\n          updated_at: new Date(),\n        })\n        .where('id', '=', id)\n        .where('workspace_id', '=', this.workspaceId)\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n  }\n\n  /**\n   * Delete a task\n   */\n  async delete(id: string): Promise<void> {\n    await this.db\n      .deleteFrom('tasks')\n      .where('id', '=', id)\n      .where('workspace_id', '=', this.workspaceId)\n      .execute();\n  }\n\n  /**\n   * Search tasks\n   */\n  async search(query: string): Promise<Task[]> {\n    return this.scoped()\n      .where(({ or, eb }) => or([\n        eb('title', 'ilike', `%${query}%`),\n        eb('description', 'ilike', `%${query}%`),\n      ]))\n      .orderBy('updated_at', 'desc')\n      .limit(50)\n      .selectAll()\n      .execute();\n  }\n}\n```\n\n## Usage in Service\n\n```typescript\n// src/modules/task/task.service.ts\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const repo = new TaskRepository(user.workspaceId);\n\n    // Validate board belongs to workspace\n    const board = await new BoardRepository(user.workspaceId)\n      .findById(input.boardId);\n\n    if (!board) {\n      throw new AppError('Board not found', 404);\n    }\n\n    const task = await repo.create({\n      ...input,\n      createdBy: user.id,\n    });\n\n    eventBus.emit('task.created', { task, userId: user.id });\n\n    return task;\n  }\n}\n```\n\n## Database Types Generation\n\n```typescript\n// src/foundation/db/types.ts (generated from schema)\nexport interface Database {\n  users: UserTable;\n  workspaces: WorkspaceTable;\n  workspace_members: WorkspaceMemberTable;\n  boards: BoardTable;\n  columns: ColumnTable;\n  tasks: TaskTable;\n  comments: CommentTable;\n}\n\nexport interface TaskTable {\n  id: Generated<string>;\n  workspace_id: string;\n  board_id: string;\n  column_id: string;\n  title: string;\n  description: string | null;\n  assignee_id: string | null;\n  due_date: Date | null;\n  position: number;\n  created_by: string;\n  created_at: Generated<Date>;\n  updated_at: Generated<Date>;\n}\n\nexport type Task = Selectable<TaskTable>;\nexport type NewTask = Insertable<TaskTable>;\nexport type TaskUpdate = Updateable<TaskTable>;\n```\n\n## Used By\n\n- [c3-1.2: DB Client](../c3-components.md#c3-12-db-client)\n- All feature module repositories\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:31:39.958Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/websocket-handler.md",
        "content": "# Reference: WebSocket Handler\n\n> Real-time communication patterns with Socket.IO and Redis\n\n## Overview\n\nThe real-time system provides:\n- Board-scoped rooms for live updates\n- User presence tracking\n- Cross-instance messaging via Redis pub/sub\n\n## Architecture\n\n```\n┌──────────────────────────────────────────────────────────────────┐\n│                        WebSocket Layer                            │\n│                                                                   │\n│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │\n│  │   Socket    │    │    Room     │    │  Presence   │          │\n│  │   Server    │───▶│   Manager   │───▶│   Tracker   │          │\n│  └─────────────┘    └─────────────┘    └─────────────┘          │\n│         │                  │                  │                  │\n│         └──────────────────┼──────────────────┘                  │\n│                            │                                     │\n│                     ┌──────┴──────┐                              │\n│                     │    Redis    │                              │\n│                     │   Adapter   │                              │\n│                     └─────────────┘                              │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n## Server Setup\n\n```typescript\n// src/modules/realtime/realtime.gateway.ts\nimport { Server as HttpServer } from 'http';\nimport { Server, Socket } from 'socket.io';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { redis, redisSub } from '@/foundation/cache';\nimport { verifyToken } from '@/foundation/auth';\nimport { RoomManager } from './rooms';\nimport { PresenceTracker } from './presence';\n\nexport class RealtimeGateway {\n  private io: Server;\n  private rooms: RoomManager;\n  private presence: PresenceTracker;\n\n  constructor(httpServer: HttpServer) {\n    this.io = new Server(httpServer, {\n      cors: {\n        origin: process.env.CLIENT_URL,\n        credentials: true,\n      },\n    });\n\n    // Redis adapter for multi-instance support\n    this.io.adapter(createAdapter(redis, redisSub));\n\n    this.rooms = new RoomManager(this.io);\n    this.presence = new PresenceTracker(redis);\n\n    this.setupMiddleware();\n    this.setupHandlers();\n  }\n\n  private setupMiddleware() {\n    // Authentication middleware\n    this.io.use(async (socket, next) => {\n      try {\n        const token = socket.handshake.auth.token;\n        if (!token) {\n          return next(new Error('Authentication required'));\n        }\n\n        const payload = await verifyToken(token);\n        socket.data.user = {\n          id: payload.sub,\n          email: payload.email,\n        };\n        next();\n      } catch (error) {\n        next(new Error('Invalid token'));\n      }\n    });\n  }\n\n  private setupHandlers() {\n    this.io.on('connection', (socket) => {\n      console.log(`User connected: ${socket.data.user.id}`);\n\n      // Board subscription\n      socket.on('subscribe:board', (boardId) =>\n        this.handleBoardSubscribe(socket, boardId)\n      );\n\n      socket.on('unsubscribe:board', (boardId) =>\n        this.handleBoardUnsubscribe(socket, boardId)\n      );\n\n      // Disconnect cleanup\n      socket.on('disconnect', () =>\n        this.handleDisconnect(socket)\n      );\n    });\n  }\n\n  private async handleBoardSubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    // TODO: Verify user has access to this board's workspace\n    socket.join(roomName);\n\n    // Track presence\n    await this.presence.join(boardId, socket.data.user);\n\n    // Notify others\n    socket.to(roomName).emit('presence:joined', {\n      user: socket.data.user,\n      boardId,\n    });\n\n    // Send current presence list\n    const users = await this.presence.getUsers(boardId);\n    socket.emit('presence:list', { boardId, users });\n  }\n\n  private async handleBoardUnsubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    socket.leave(roomName);\n    await this.presence.leave(boardId, socket.data.user.id);\n\n    socket.to(roomName).emit('presence:left', {\n      userId: socket.data.user.id,\n      boardId,\n    });\n  }\n\n  private async handleDisconnect(socket: Socket) {\n    // Clean up all room presences\n    const rooms = [...socket.rooms].filter(r => r.startsWith('board:'));\n\n    for (const room of rooms) {\n      const boardId = room.replace('board:', '');\n      await this.presence.leave(boardId, socket.data.user.id);\n\n      socket.to(room).emit('presence:left', {\n        userId: socket.data.user.id,\n        boardId,\n      });\n    }\n  }\n\n  /**\n   * Broadcast event to a board room\n   */\n  broadcastToBoard(boardId: string, event: string, data: any) {\n    this.io.to(`board:${boardId}`).emit(event, data);\n  }\n}\n```\n\n## Room Manager\n\n```typescript\n// src/modules/realtime/rooms.ts\nimport { Server } from 'socket.io';\n\nexport class RoomManager {\n  constructor(private io: Server) {}\n\n  /**\n   * Broadcast to all users viewing a board\n   */\n  broadcast(boardId: string, event: string, payload: any) {\n    this.io.to(`board:${boardId}`).emit(event, payload);\n  }\n\n  /**\n   * Get count of users in a board room\n   */\n  async getViewerCount(boardId: string): Promise<number> {\n    const sockets = await this.io.in(`board:${boardId}`).fetchSockets();\n    return sockets.length;\n  }\n}\n```\n\n## Presence Tracker\n\n```typescript\n// src/modules/realtime/presence.ts\nimport { Redis } from 'ioredis';\n\ninterface PresenceUser {\n  id: string;\n  email: string;\n  joinedAt: number;\n}\n\nexport class PresenceTracker {\n  private readonly TTL = 300; // 5 minutes\n\n  constructor(private redis: Redis) {}\n\n  async join(boardId: string, user: { id: string; email: string }) {\n    const key = this.key(boardId);\n    const member: PresenceUser = {\n      id: user.id,\n      email: user.email,\n      joinedAt: Date.now(),\n    };\n\n    await this.redis.hset(key, user.id, JSON.stringify(member));\n    await this.redis.expire(key, this.TTL);\n  }\n\n  async leave(boardId: string, userId: string) {\n    await this.redis.hdel(this.key(boardId), userId);\n  }\n\n  async getUsers(boardId: string): Promise<PresenceUser[]> {\n    const data = await this.redis.hgetall(this.key(boardId));\n    return Object.values(data).map(v => JSON.parse(v));\n  }\n\n  async heartbeat(boardId: string, userId: string) {\n    await this.redis.expire(this.key(boardId), this.TTL);\n  }\n\n  private key(boardId: string) {\n    return `presence:board:${boardId}`;\n  }\n}\n```\n\n## Domain Event Integration\n\n```typescript\n// src/modules/realtime/event-bridge.ts\nimport { eventBus } from '@/foundation/events';\nimport { RealtimeGateway } from './realtime.gateway';\n\nexport function setupEventBridge(gateway: RealtimeGateway) {\n  // Task events\n  eventBus.on('task.created', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:created', task);\n  });\n\n  eventBus.on('task.updated', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:updated', task);\n  });\n\n  eventBus.on('task.moved', ({ task, fromColumnId, toColumnId }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:moved', {\n      task,\n      fromColumnId,\n      toColumnId,\n    });\n  });\n\n  eventBus.on('task.deleted', ({ taskId, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'task:deleted', { taskId });\n  });\n\n  // Column events\n  eventBus.on('column.created', ({ column, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:created', column);\n  });\n\n  eventBus.on('column.reordered', ({ columns, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:reordered', { columns });\n  });\n}\n```\n\n## Client Integration\n\n```typescript\n// Frontend: src/lib/realtime.ts\nimport { io, Socket } from 'socket.io-client';\n\nclass RealtimeClient {\n  private socket: Socket | null = null;\n  private subscribedBoards = new Set<string>();\n\n  connect(token: string) {\n    this.socket = io(import.meta.env.VITE_WS_URL, {\n      auth: { token },\n      reconnection: true,\n      reconnectionDelay: 1000,\n    });\n\n    this.socket.on('connect', () => {\n      // Re-subscribe to boards on reconnect\n      this.subscribedBoards.forEach(boardId => {\n        this.socket?.emit('subscribe:board', boardId);\n      });\n    });\n  }\n\n  subscribeToBoard(boardId: string, handlers: BoardEventHandlers) {\n    if (!this.socket) return;\n\n    this.subscribedBoards.add(boardId);\n    this.socket.emit('subscribe:board', boardId);\n\n    this.socket.on('task:created', handlers.onTaskCreated);\n    this.socket.on('task:updated', handlers.onTaskUpdated);\n    this.socket.on('task:moved', handlers.onTaskMoved);\n    this.socket.on('task:deleted', handlers.onTaskDeleted);\n    this.socket.on('presence:list', handlers.onPresenceList);\n    this.socket.on('presence:joined', handlers.onPresenceJoined);\n    this.socket.on('presence:left', handlers.onPresenceLeft);\n  }\n\n  unsubscribeFromBoard(boardId: string) {\n    this.subscribedBoards.delete(boardId);\n    this.socket?.emit('unsubscribe:board', boardId);\n  }\n\n  disconnect() {\n    this.socket?.disconnect();\n    this.socket = null;\n  }\n}\n\nexport const realtime = new RealtimeClient();\n```\n\n## Event Types\n\n```typescript\n// Shared event types\ninterface BoardEvents {\n  // Task events\n  'task:created': (task: Task) => void;\n  'task:updated': (task: Task) => void;\n  'task:moved': (data: { task: Task; fromColumnId: string; toColumnId: string }) => void;\n  'task:deleted': (data: { taskId: string }) => void;\n\n  // Column events\n  'column:created': (column: Column) => void;\n  'column:reordered': (data: { columns: Column[] }) => void;\n\n  // Presence events\n  'presence:list': (data: { boardId: string; users: PresenceUser[] }) => void;\n  'presence:joined': (data: { user: PresenceUser; boardId: string }) => void;\n  'presence:left': (data: { userId: string; boardId: string }) => void;\n}\n```\n\n## Used By\n\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- [c3-0.3: Realtime Client](../c3-components.md#c3-03-realtime-client)\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:31:39.975Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/websocket-handler.md",
        "content": "# Reference: WebSocket Handler\n\n> Real-time communication patterns with Socket.IO and Redis\n\n## Overview\n\nThe real-time system provides:\n- Board-scoped rooms for live updates\n- User presence tracking\n- Cross-instance messaging via Redis pub/sub\n\n## Architecture\n\n```\n┌──────────────────────────────────────────────────────────────────┐\n│                        WebSocket Layer                            │\n│                                                                   │\n│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │\n│  │   Socket    │    │    Room     │    │  Presence   │          │\n│  │   Server    │───▶│   Manager   │───▶│   Tracker   │          │\n│  └─────────────┘    └─────────────┘    └─────────────┘          │\n│         │                  │                  │                  │\n│         └──────────────────┼──────────────────┘                  │\n│                            │                                     │\n│                     ┌──────┴──────┐                              │\n│                     │    Redis    │                              │\n│                     │   Adapter   │                              │\n│                     └─────────────┘                              │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n## Server Setup\n\n```typescript\n// src/modules/realtime/realtime.gateway.ts\nimport { Server as HttpServer } from 'http';\nimport { Server, Socket } from 'socket.io';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { redis, redisSub } from '@/foundation/cache';\nimport { verifyToken } from '@/foundation/auth';\nimport { RoomManager } from './rooms';\nimport { PresenceTracker } from './presence';\n\nexport class RealtimeGateway {\n  private io: Server;\n  private rooms: RoomManager;\n  private presence: PresenceTracker;\n\n  constructor(httpServer: HttpServer) {\n    this.io = new Server(httpServer, {\n      cors: {\n        origin: process.env.CLIENT_URL,\n        credentials: true,\n      },\n    });\n\n    // Redis adapter for multi-instance support\n    this.io.adapter(createAdapter(redis, redisSub));\n\n    this.rooms = new RoomManager(this.io);\n    this.presence = new PresenceTracker(redis);\n\n    this.setupMiddleware();\n    this.setupHandlers();\n  }\n\n  private setupMiddleware() {\n    // Authentication middleware\n    this.io.use(async (socket, next) => {\n      try {\n        const token = socket.handshake.auth.token;\n        if (!token) {\n          return next(new Error('Authentication required'));\n        }\n\n        const payload = await verifyToken(token);\n        socket.data.user = {\n          id: payload.sub,\n          email: payload.email,\n        };\n        next();\n      } catch (error) {\n        next(new Error('Invalid token'));\n      }\n    });\n  }\n\n  private setupHandlers() {\n    this.io.on('connection', (socket) => {\n      console.log(`User connected: ${socket.data.user.id}`);\n\n      // Board subscription\n      socket.on('subscribe:board', (boardId) =>\n        this.handleBoardSubscribe(socket, boardId)\n      );\n\n      socket.on('unsubscribe:board', (boardId) =>\n        this.handleBoardUnsubscribe(socket, boardId)\n      );\n\n      // Disconnect cleanup\n      socket.on('disconnect', () =>\n        this.handleDisconnect(socket)\n      );\n    });\n  }\n\n  private async handleBoardSubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    // TODO: Verify user has access to this board's workspace\n    socket.join(roomName);\n\n    // Track presence\n    await this.presence.join(boardId, socket.data.user);\n\n    // Notify others\n    socket.to(roomName).emit('presence:joined', {\n      user: socket.data.user,\n      boardId,\n    });\n\n    // Send current presence list\n    const users = await this.presence.getUsers(boardId);\n    socket.emit('presence:list', { boardId, users });\n  }\n\n  private async handleBoardUnsubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    socket.leave(roomName);\n    await this.presence.leave(boardId, socket.data.user.id);\n\n    socket.to(roomName).emit('presence:left', {\n      userId: socket.data.user.id,\n      boardId,\n    });\n  }\n\n  private async handleDisconnect(socket: Socket) {\n    // Clean up all room presences\n    const rooms = [...socket.rooms].filter(r => r.startsWith('board:'));\n\n    for (const room of rooms) {\n      const boardId = room.replace('board:', '');\n      await this.presence.leave(boardId, socket.data.user.id);\n\n      socket.to(room).emit('presence:left', {\n        userId: socket.data.user.id,\n        boardId,\n      });\n    }\n  }\n\n  /**\n   * Broadcast event to a board room\n   */\n  broadcastToBoard(boardId: string, event: string, data: any) {\n    this.io.to(`board:${boardId}`).emit(event, data);\n  }\n}\n```\n\n## Room Manager\n\n```typescript\n// src/modules/realtime/rooms.ts\nimport { Server } from 'socket.io';\n\nexport class RoomManager {\n  constructor(private io: Server) {}\n\n  /**\n   * Broadcast to all users viewing a board\n   */\n  broadcast(boardId: string, event: string, payload: any) {\n    this.io.to(`board:${boardId}`).emit(event, payload);\n  }\n\n  /**\n   * Get count of users in a board room\n   */\n  async getViewerCount(boardId: string): Promise<number> {\n    const sockets = await this.io.in(`board:${boardId}`).fetchSockets();\n    return sockets.length;\n  }\n}\n```\n\n## Presence Tracker\n\n```typescript\n// src/modules/realtime/presence.ts\nimport { Redis } from 'ioredis';\n\ninterface PresenceUser {\n  id: string;\n  email: string;\n  joinedAt: number;\n}\n\nexport class PresenceTracker {\n  private readonly TTL = 300; // 5 minutes\n\n  constructor(private redis: Redis) {}\n\n  async join(boardId: string, user: { id: string; email: string }) {\n    const key = this.key(boardId);\n    const member: PresenceUser = {\n      id: user.id,\n      email: user.email,\n      joinedAt: Date.now(),\n    };\n\n    await this.redis.hset(key, user.id, JSON.stringify(member));\n    await this.redis.expire(key, this.TTL);\n  }\n\n  async leave(boardId: string, userId: string) {\n    await this.redis.hdel(this.key(boardId), userId);\n  }\n\n  async getUsers(boardId: string): Promise<PresenceUser[]> {\n    const data = await this.redis.hgetall(this.key(boardId));\n    return Object.values(data).map(v => JSON.parse(v));\n  }\n\n  async heartbeat(boardId: string, userId: string) {\n    await this.redis.expire(this.key(boardId), this.TTL);\n  }\n\n  private key(boardId: string) {\n    return `presence:board:${boardId}`;\n  }\n}\n```\n\n## Domain Event Integration\n\n```typescript\n// src/modules/realtime/event-bridge.ts\nimport { eventBus } from '@/foundation/events';\nimport { RealtimeGateway } from './realtime.gateway';\n\nexport function setupEventBridge(gateway: RealtimeGateway) {\n  // Task events\n  eventBus.on('task.created', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:created', task);\n  });\n\n  eventBus.on('task.updated', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:updated', task);\n  });\n\n  eventBus.on('task.moved', ({ task, fromColumnId, toColumnId }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:moved', {\n      task,\n      fromColumnId,\n      toColumnId,\n    });\n  });\n\n  eventBus.on('task.deleted', ({ taskId, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'task:deleted', { taskId });\n  });\n\n  // Column events\n  eventBus.on('column.created', ({ column, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:created', column);\n  });\n\n  eventBus.on('column.reordered', ({ columns, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:reordered', { columns });\n  });\n}\n```\n\n## Client Integration\n\n```typescript\n// Frontend: src/lib/realtime.ts\nimport { io, Socket } from 'socket.io-client';\n\nclass RealtimeClient {\n  private socket: Socket | null = null;\n  private subscribedBoards = new Set<string>();\n\n  connect(token: string) {\n    this.socket = io(import.meta.env.VITE_WS_URL, {\n      auth: { token },\n      reconnection: true,\n      reconnectionDelay: 1000,\n    });\n\n    this.socket.on('connect', () => {\n      // Re-subscribe to boards on reconnect\n      this.subscribedBoards.forEach(boardId => {\n        this.socket?.emit('subscribe:board', boardId);\n      });\n    });\n  }\n\n  subscribeToBoard(boardId: string, handlers: BoardEventHandlers) {\n    if (!this.socket) return;\n\n    this.subscribedBoards.add(boardId);\n    this.socket.emit('subscribe:board', boardId);\n\n    this.socket.on('task:created', handlers.onTaskCreated);\n    this.socket.on('task:updated', handlers.onTaskUpdated);\n    this.socket.on('task:moved', handlers.onTaskMoved);\n    this.socket.on('task:deleted', handlers.onTaskDeleted);\n    this.socket.on('presence:list', handlers.onPresenceList);\n    this.socket.on('presence:joined', handlers.onPresenceJoined);\n    this.socket.on('presence:left', handlers.onPresenceLeft);\n  }\n\n  unsubscribeFromBoard(boardId: string) {\n    this.subscribedBoards.delete(boardId);\n    this.socket?.emit('unsubscribe:board', boardId);\n  }\n\n  disconnect() {\n    this.socket?.disconnect();\n    this.socket = null;\n  }\n}\n\nexport const realtime = new RealtimeClient();\n```\n\n## Event Types\n\n```typescript\n// Shared event types\ninterface BoardEvents {\n  // Task events\n  'task:created': (task: Task) => void;\n  'task:updated': (task: Task) => void;\n  'task:moved': (data: { task: Task; fromColumnId: string; toColumnId: string }) => void;\n  'task:deleted': (data: { taskId: string }) => void;\n\n  // Column events\n  'column:created': (column: Column) => void;\n  'column:reordered': (data: { columns: Column[] }) => void;\n\n  // Presence events\n  'presence:list': (data: { boardId: string; users: PresenceUser[] }) => void;\n  'presence:joined': (data: { user: PresenceUser; boardId: string }) => void;\n  'presence:left': (data: { userId: string; boardId: string }) => void;\n}\n```\n\n## Used By\n\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- [c3-0.3: Realtime Client](../c3-components.md#c3-03-realtime-client)\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/websocket-handler.md",
        "content": "# Reference: WebSocket Handler\n\n> Real-time communication patterns with Socket.IO and Redis\n\n## Overview\n\nThe real-time system provides:\n- Board-scoped rooms for live updates\n- User presence tracking\n- Cross-instance messaging via Redis pub/sub\n\n## Architecture\n\n```\n┌──────────────────────────────────────────────────────────────────┐\n│                        WebSocket Layer                            │\n│                                                                   │\n│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐          │\n│  │   Socket    │    │    Room     │    │  Presence   │          │\n│  │   Server    │───▶│   Manager   │───▶│   Tracker   │          │\n│  └─────────────┘    └─────────────┘    └─────────────┘          │\n│         │                  │                  │                  │\n│         └──────────────────┼──────────────────┘                  │\n│                            │                                     │\n│                     ┌──────┴──────┐                              │\n│                     │    Redis    │                              │\n│                     │   Adapter   │                              │\n│                     └─────────────┘                              │\n└──────────────────────────────────────────────────────────────────┘\n```\n\n## Server Setup\n\n```typescript\n// src/modules/realtime/realtime.gateway.ts\nimport { Server as HttpServer } from 'http';\nimport { Server, Socket } from 'socket.io';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { redis, redisSub } from '@/foundation/cache';\nimport { verifyToken } from '@/foundation/auth';\nimport { RoomManager } from './rooms';\nimport { PresenceTracker } from './presence';\n\nexport class RealtimeGateway {\n  private io: Server;\n  private rooms: RoomManager;\n  private presence: PresenceTracker;\n\n  constructor(httpServer: HttpServer) {\n    this.io = new Server(httpServer, {\n      cors: {\n        origin: process.env.CLIENT_URL,\n        credentials: true,\n      },\n    });\n\n    // Redis adapter for multi-instance support\n    this.io.adapter(createAdapter(redis, redisSub));\n\n    this.rooms = new RoomManager(this.io);\n    this.presence = new PresenceTracker(redis);\n\n    this.setupMiddleware();\n    this.setupHandlers();\n  }\n\n  private setupMiddleware() {\n    // Authentication middleware\n    this.io.use(async (socket, next) => {\n      try {\n        const token = socket.handshake.auth.token;\n        if (!token) {\n          return next(new Error('Authentication required'));\n        }\n\n        const payload = await verifyToken(token);\n        socket.data.user = {\n          id: payload.sub,\n          email: payload.email,\n        };\n        next();\n      } catch (error) {\n        next(new Error('Invalid token'));\n      }\n    });\n  }\n\n  private setupHandlers() {\n    this.io.on('connection', (socket) => {\n      console.log(`User connected: ${socket.data.user.id}`);\n\n      // Board subscription\n      socket.on('subscribe:board', (boardId) =>\n        this.handleBoardSubscribe(socket, boardId)\n      );\n\n      socket.on('unsubscribe:board', (boardId) =>\n        this.handleBoardUnsubscribe(socket, boardId)\n      );\n\n      // Disconnect cleanup\n      socket.on('disconnect', () =>\n        this.handleDisconnect(socket)\n      );\n    });\n  }\n\n  private async handleBoardSubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    // TODO: Verify user has access to this board's workspace\n    socket.join(roomName);\n\n    // Track presence\n    await this.presence.join(boardId, socket.data.user);\n\n    // Notify others\n    socket.to(roomName).emit('presence:joined', {\n      user: socket.data.user,\n      boardId,\n    });\n\n    // Send current presence list\n    const users = await this.presence.getUsers(boardId);\n    socket.emit('presence:list', { boardId, users });\n  }\n\n  private async handleBoardUnsubscribe(socket: Socket, boardId: string) {\n    const roomName = `board:${boardId}`;\n\n    socket.leave(roomName);\n    await this.presence.leave(boardId, socket.data.user.id);\n\n    socket.to(roomName).emit('presence:left', {\n      userId: socket.data.user.id,\n      boardId,\n    });\n  }\n\n  private async handleDisconnect(socket: Socket) {\n    // Clean up all room presences\n    const rooms = [...socket.rooms].filter(r => r.startsWith('board:'));\n\n    for (const room of rooms) {\n      const boardId = room.replace('board:', '');\n      await this.presence.leave(boardId, socket.data.user.id);\n\n      socket.to(room).emit('presence:left', {\n        userId: socket.data.user.id,\n        boardId,\n      });\n    }\n  }\n\n  /**\n   * Broadcast event to a board room\n   */\n  broadcastToBoard(boardId: string, event: string, data: any) {\n    this.io.to(`board:${boardId}`).emit(event, data);\n  }\n}\n```\n\n## Room Manager\n\n```typescript\n// src/modules/realtime/rooms.ts\nimport { Server } from 'socket.io';\n\nexport class RoomManager {\n  constructor(private io: Server) {}\n\n  /**\n   * Broadcast to all users viewing a board\n   */\n  broadcast(boardId: string, event: string, payload: any) {\n    this.io.to(`board:${boardId}`).emit(event, payload);\n  }\n\n  /**\n   * Get count of users in a board room\n   */\n  async getViewerCount(boardId: string): Promise<number> {\n    const sockets = await this.io.in(`board:${boardId}`).fetchSockets();\n    return sockets.length;\n  }\n}\n```\n\n## Presence Tracker\n\n```typescript\n// src/modules/realtime/presence.ts\nimport { Redis } from 'ioredis';\n\ninterface PresenceUser {\n  id: string;\n  email: string;\n  joinedAt: number;\n}\n\nexport class PresenceTracker {\n  private readonly TTL = 300; // 5 minutes\n\n  constructor(private redis: Redis) {}\n\n  async join(boardId: string, user: { id: string; email: string }) {\n    const key = this.key(boardId);\n    const member: PresenceUser = {\n      id: user.id,\n      email: user.email,\n      joinedAt: Date.now(),\n    };\n\n    await this.redis.hset(key, user.id, JSON.stringify(member));\n    await this.redis.expire(key, this.TTL);\n  }\n\n  async leave(boardId: string, userId: string) {\n    await this.redis.hdel(this.key(boardId), userId);\n  }\n\n  async getUsers(boardId: string): Promise<PresenceUser[]> {\n    const data = await this.redis.hgetall(this.key(boardId));\n    return Object.values(data).map(v => JSON.parse(v));\n  }\n\n  async heartbeat(boardId: string, userId: string) {\n    await this.redis.expire(this.key(boardId), this.TTL);\n  }\n\n  private key(boardId: string) {\n    return `presence:board:${boardId}`;\n  }\n}\n```\n\n## Domain Event Integration\n\n```typescript\n// src/modules/realtime/event-bridge.ts\nimport { eventBus } from '@/foundation/events';\nimport { RealtimeGateway } from './realtime.gateway';\n\nexport function setupEventBridge(gateway: RealtimeGateway) {\n  // Task events\n  eventBus.on('task.created', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:created', task);\n  });\n\n  eventBus.on('task.updated', ({ task }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:updated', task);\n  });\n\n  eventBus.on('task.moved', ({ task, fromColumnId, toColumnId }) => {\n    gateway.broadcastToBoard(task.boardId, 'task:moved', {\n      task,\n      fromColumnId,\n      toColumnId,\n    });\n  });\n\n  eventBus.on('task.deleted', ({ taskId, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'task:deleted', { taskId });\n  });\n\n  // Column events\n  eventBus.on('column.created', ({ column, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:created', column);\n  });\n\n  eventBus.on('column.reordered', ({ columns, boardId }) => {\n    gateway.broadcastToBoard(boardId, 'column:reordered', { columns });\n  });\n}\n```\n\n## Client Integration\n\n```typescript\n// Frontend: src/lib/realtime.ts\nimport { io, Socket } from 'socket.io-client';\n\nclass RealtimeClient {\n  private socket: Socket | null = null;\n  private subscribedBoards = new Set<string>();\n\n  connect(token: string) {\n    this.socket = io(import.meta.env.VITE_WS_URL, {\n      auth: { token },\n      reconnection: true,\n      reconnectionDelay: 1000,\n    });\n\n    this.socket.on('connect', () => {\n      // Re-subscribe to boards on reconnect\n      this.subscribedBoards.forEach(boardId => {\n        this.socket?.emit('subscribe:board', boardId);\n      });\n    });\n  }\n\n  subscribeToBoard(boardId: string, handlers: BoardEventHandlers) {\n    if (!this.socket) return;\n\n    this.subscribedBoards.add(boardId);\n    this.socket.emit('subscribe:board', boardId);\n\n    this.socket.on('task:created', handlers.onTaskCreated);\n    this.socket.on('task:updated', handlers.onTaskUpdated);\n    this.socket.on('task:moved', handlers.onTaskMoved);\n    this.socket.on('task:deleted', handlers.onTaskDeleted);\n    this.socket.on('presence:list', handlers.onPresenceList);\n    this.socket.on('presence:joined', handlers.onPresenceJoined);\n    this.socket.on('presence:left', handlers.onPresenceLeft);\n  }\n\n  unsubscribeFromBoard(boardId: string) {\n    this.subscribedBoards.delete(boardId);\n    this.socket?.emit('unsubscribe:board', boardId);\n  }\n\n  disconnect() {\n    this.socket?.disconnect();\n    this.socket = null;\n  }\n}\n\nexport const realtime = new RealtimeClient();\n```\n\n## Event Types\n\n```typescript\n// Shared event types\ninterface BoardEvents {\n  // Task events\n  'task:created': (task: Task) => void;\n  'task:updated': (task: Task) => void;\n  'task:moved': (data: { task: Task; fromColumnId: string; toColumnId: string }) => void;\n  'task:deleted': (data: { taskId: string }) => void;\n\n  // Column events\n  'column:created': (column: Column) => void;\n  'column:reordered': (data: { columns: Column[] }) => void;\n\n  // Presence events\n  'presence:list': (data: { boardId: string; users: PresenceUser[] }) => void;\n  'presence:joined': (data: { user: PresenceUser; boardId: string }) => void;\n  'presence:left': (data: { userId: string; boardId: string }) => void;\n}\n```\n\n## Used By\n\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- [c3-0.3: Realtime Client](../c3-components.md#c3-03-realtime-client)\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:32:10.311Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/event-bus.md",
        "content": "# Reference: Event Bus\n\n> Domain event publishing and subscription patterns\n\n## Overview\n\nThe event bus enables:\n- Loose coupling between modules\n- Cross-instance event broadcast via Redis\n- Extensibility for future integrations (webhooks, analytics)\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         Event Flow                               │\n│                                                                  │\n│  ┌──────────┐    publish     ┌───────────────┐                  │\n│  │  Module  │───────────────▶│   Event Bus   │                  │\n│  └──────────┘                └───────┬───────┘                  │\n│                                      │                          │\n│              ┌───────────────────────┼───────────────────────┐  │\n│              │                       │                       │  │\n│              ▼                       ▼                       ▼  │\n│     ┌────────────────┐     ┌────────────────┐     ┌───────────┐ │\n│     │  Local Handler │     │ Redis Pub/Sub  │     │  Handler  │ │\n│     │  (same process)│     │  (broadcast)   │     │  (other)  │ │\n│     └────────────────┘     └────────────────┘     └───────────┘ │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n```typescript\n// src/foundation/events/bus.ts\nimport { EventEmitter } from 'eventemitter3';\nimport { Redis } from 'ioredis';\nimport { DomainEvent, EventHandler } from './types';\n\nexport class EventBus {\n  private emitter = new EventEmitter();\n  private redis: Redis;\n  private redisSub: Redis;\n  private channel = 'taskflow:events';\n\n  constructor(redis: Redis, redisSub: Redis) {\n    this.redis = redis;\n    this.redisSub = redisSub;\n    this.setupRedisSubscription();\n  }\n\n  /**\n   * Emit an event locally and broadcast via Redis\n   */\n  async emit<T extends DomainEvent>(\n    type: T['type'],\n    payload: T['payload'],\n    options: { broadcast?: boolean } = { broadcast: true }\n  ) {\n    const event = { type, payload, timestamp: Date.now() };\n\n    // Local handlers\n    this.emitter.emit(type, payload);\n\n    // Broadcast to other instances\n    if (options.broadcast) {\n      await this.redis.publish(this.channel, JSON.stringify(event));\n    }\n  }\n\n  /**\n   * Subscribe to an event type\n   */\n  on<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.on(type, handler);\n    return () => this.emitter.off(type, handler);\n  }\n\n  /**\n   * One-time subscription\n   */\n  once<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.once(type, handler);\n  }\n\n  private setupRedisSubscription() {\n    this.redisSub.subscribe(this.channel);\n\n    this.redisSub.on('message', (channel, message) => {\n      if (channel !== this.channel) return;\n\n      try {\n        const event = JSON.parse(message);\n        // Emit locally without re-broadcasting\n        this.emitter.emit(event.type, event.payload);\n      } catch (error) {\n        console.error('Failed to parse event:', error);\n      }\n    });\n  }\n}\n```\n\n## Event Types\n\n```typescript\n// src/foundation/events/types.ts\n\n// Task events\nexport interface TaskCreatedEvent {\n  type: 'task.created';\n  payload: { task: Task; userId: string };\n}\n\nexport interface TaskUpdatedEvent {\n  type: 'task.updated';\n  payload: { task: Task; userId: string; changes: Partial<Task> };\n}\n\nexport interface TaskMovedEvent {\n  type: 'task.moved';\n  payload: {\n    task: Task;\n    fromColumnId: string;\n    toColumnId: string;\n    userId: string;\n  };\n}\n\nexport interface TaskDeletedEvent {\n  type: 'task.deleted';\n  payload: { taskId: string; boardId: string; userId: string };\n}\n\nexport interface TaskAssignedEvent {\n  type: 'task.assigned';\n  payload: { taskId: string; assigneeId: string; assignedBy: string };\n}\n\n// Board events\nexport interface BoardUpdatedEvent {\n  type: 'board.updated';\n  payload: { board: Board; userId: string };\n}\n\nexport interface ColumnCreatedEvent {\n  type: 'column.created';\n  payload: { column: Column; boardId: string };\n}\n\nexport interface ColumnReorderedEvent {\n  type: 'column.reordered';\n  payload: { columns: Column[]; boardId: string };\n}\n\n// Workspace events\nexport interface UserJoinedWorkspaceEvent {\n  type: 'workspace.user_joined';\n  payload: { userId: string; workspaceId: string; role: string };\n}\n\n// Union type\nexport type DomainEvent =\n  | TaskCreatedEvent\n  | TaskUpdatedEvent\n  | TaskMovedEvent\n  | TaskDeletedEvent\n  | TaskAssignedEvent\n  | BoardUpdatedEvent\n  | ColumnCreatedEvent\n  | ColumnReorderedEvent\n  | UserJoinedWorkspaceEvent;\n\n// Handler type\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n```\n\n## Usage in Modules\n\n### Publishing Events\n\n```typescript\n// src/modules/task/task.service.ts\nimport { eventBus } from '@/foundation/events';\n\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Publish domain event\n    await eventBus.emit('task.created', {\n      task,\n      userId: user.id,\n    });\n\n    return task;\n  }\n\n  async move(taskId: string, columnId: string, position: number, user: AuthUser) {\n    const task = await this.repo.findById(taskId);\n    const fromColumnId = task.columnId;\n\n    const updated = await this.repo.move(taskId, columnId, position);\n\n    await eventBus.emit('task.moved', {\n      task: updated,\n      fromColumnId,\n      toColumnId: columnId,\n      userId: user.id,\n    });\n\n    return updated;\n  }\n}\n```\n\n### Subscribing to Events\n\n```typescript\n// src/modules/notification/notification.listener.ts\nimport { eventBus } from '@/foundation/events';\nimport { NotificationService } from './notification.service';\n\nconst notifications = new NotificationService();\n\n// Task assignment notification\neventBus.on('task.assigned', async ({ taskId, assigneeId, assignedBy }) => {\n  if (assigneeId !== assignedBy) {\n    await notifications.create({\n      userId: assigneeId,\n      type: 'task_assigned',\n      title: 'New task assigned',\n      data: { taskId },\n    });\n  }\n});\n\n// Due date reminder\neventBus.on('task.updated', async ({ task, changes }) => {\n  if (changes.dueDate && task.assigneeId) {\n    await notifications.scheduleDueReminder(task);\n  }\n});\n```\n\n## Cache Invalidation\n\n```typescript\n// src/foundation/cache/invalidation.ts\nimport { eventBus } from '@/foundation/events';\nimport { cache } from './client';\n\n// Invalidate task cache on updates\neventBus.on('task.updated', async ({ task }) => {\n  await cache.del(`task:${task.id}`);\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.created', async ({ task }) => {\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.deleted', async ({ taskId, boardId }) => {\n  await cache.del(`task:${taskId}`);\n  await cache.del(`board:${boardId}:tasks`);\n});\n```\n\n## Singleton Instance\n\n```typescript\n// src/foundation/events/index.ts\nimport { EventBus } from './bus';\nimport { redis, redisSub } from '@/foundation/cache';\n\nexport const eventBus = new EventBus(redis, redisSub);\n\nexport * from './types';\n```\n\n## Used By\n\n- [c3-1.4: Events Bus](../c3-components.md#c3-14-events-bus)\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- All feature modules (publishing events)\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:32:10.332Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/event-bus.md",
        "content": "# Reference: Event Bus\n\n> Domain event publishing and subscription patterns\n\n## Overview\n\nThe event bus enables:\n- Loose coupling between modules\n- Cross-instance event broadcast via Redis\n- Extensibility for future integrations (webhooks, analytics)\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         Event Flow                               │\n│                                                                  │\n│  ┌──────────┐    publish     ┌───────────────┐                  │\n│  │  Module  │───────────────▶│   Event Bus   │                  │\n│  └──────────┘                └───────┬───────┘                  │\n│                                      │                          │\n│              ┌───────────────────────┼───────────────────────┐  │\n│              │                       │                       │  │\n│              ▼                       ▼                       ▼  │\n│     ┌────────────────┐     ┌────────────────┐     ┌───────────┐ │\n│     │  Local Handler │     │ Redis Pub/Sub  │     │  Handler  │ │\n│     │  (same process)│     │  (broadcast)   │     │  (other)  │ │\n│     └────────────────┘     └────────────────┘     └───────────┘ │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n```typescript\n// src/foundation/events/bus.ts\nimport { EventEmitter } from 'eventemitter3';\nimport { Redis } from 'ioredis';\nimport { DomainEvent, EventHandler } from './types';\n\nexport class EventBus {\n  private emitter = new EventEmitter();\n  private redis: Redis;\n  private redisSub: Redis;\n  private channel = 'taskflow:events';\n\n  constructor(redis: Redis, redisSub: Redis) {\n    this.redis = redis;\n    this.redisSub = redisSub;\n    this.setupRedisSubscription();\n  }\n\n  /**\n   * Emit an event locally and broadcast via Redis\n   */\n  async emit<T extends DomainEvent>(\n    type: T['type'],\n    payload: T['payload'],\n    options: { broadcast?: boolean } = { broadcast: true }\n  ) {\n    const event = { type, payload, timestamp: Date.now() };\n\n    // Local handlers\n    this.emitter.emit(type, payload);\n\n    // Broadcast to other instances\n    if (options.broadcast) {\n      await this.redis.publish(this.channel, JSON.stringify(event));\n    }\n  }\n\n  /**\n   * Subscribe to an event type\n   */\n  on<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.on(type, handler);\n    return () => this.emitter.off(type, handler);\n  }\n\n  /**\n   * One-time subscription\n   */\n  once<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.once(type, handler);\n  }\n\n  private setupRedisSubscription() {\n    this.redisSub.subscribe(this.channel);\n\n    this.redisSub.on('message', (channel, message) => {\n      if (channel !== this.channel) return;\n\n      try {\n        const event = JSON.parse(message);\n        // Emit locally without re-broadcasting\n        this.emitter.emit(event.type, event.payload);\n      } catch (error) {\n        console.error('Failed to parse event:', error);\n      }\n    });\n  }\n}\n```\n\n## Event Types\n\n```typescript\n// src/foundation/events/types.ts\n\n// Task events\nexport interface TaskCreatedEvent {\n  type: 'task.created';\n  payload: { task: Task; userId: string };\n}\n\nexport interface TaskUpdatedEvent {\n  type: 'task.updated';\n  payload: { task: Task; userId: string; changes: Partial<Task> };\n}\n\nexport interface TaskMovedEvent {\n  type: 'task.moved';\n  payload: {\n    task: Task;\n    fromColumnId: string;\n    toColumnId: string;\n    userId: string;\n  };\n}\n\nexport interface TaskDeletedEvent {\n  type: 'task.deleted';\n  payload: { taskId: string; boardId: string; userId: string };\n}\n\nexport interface TaskAssignedEvent {\n  type: 'task.assigned';\n  payload: { taskId: string; assigneeId: string; assignedBy: string };\n}\n\n// Board events\nexport interface BoardUpdatedEvent {\n  type: 'board.updated';\n  payload: { board: Board; userId: string };\n}\n\nexport interface ColumnCreatedEvent {\n  type: 'column.created';\n  payload: { column: Column; boardId: string };\n}\n\nexport interface ColumnReorderedEvent {\n  type: 'column.reordered';\n  payload: { columns: Column[]; boardId: string };\n}\n\n// Workspace events\nexport interface UserJoinedWorkspaceEvent {\n  type: 'workspace.user_joined';\n  payload: { userId: string; workspaceId: string; role: string };\n}\n\n// Union type\nexport type DomainEvent =\n  | TaskCreatedEvent\n  | TaskUpdatedEvent\n  | TaskMovedEvent\n  | TaskDeletedEvent\n  | TaskAssignedEvent\n  | BoardUpdatedEvent\n  | ColumnCreatedEvent\n  | ColumnReorderedEvent\n  | UserJoinedWorkspaceEvent;\n\n// Handler type\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n```\n\n## Usage in Modules\n\n### Publishing Events\n\n```typescript\n// src/modules/task/task.service.ts\nimport { eventBus } from '@/foundation/events';\n\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Publish domain event\n    await eventBus.emit('task.created', {\n      task,\n      userId: user.id,\n    });\n\n    return task;\n  }\n\n  async move(taskId: string, columnId: string, position: number, user: AuthUser) {\n    const task = await this.repo.findById(taskId);\n    const fromColumnId = task.columnId;\n\n    const updated = await this.repo.move(taskId, columnId, position);\n\n    await eventBus.emit('task.moved', {\n      task: updated,\n      fromColumnId,\n      toColumnId: columnId,\n      userId: user.id,\n    });\n\n    return updated;\n  }\n}\n```\n\n### Subscribing to Events\n\n```typescript\n// src/modules/notification/notification.listener.ts\nimport { eventBus } from '@/foundation/events';\nimport { NotificationService } from './notification.service';\n\nconst notifications = new NotificationService();\n\n// Task assignment notification\neventBus.on('task.assigned', async ({ taskId, assigneeId, assignedBy }) => {\n  if (assigneeId !== assignedBy) {\n    await notifications.create({\n      userId: assigneeId,\n      type: 'task_assigned',\n      title: 'New task assigned',\n      data: { taskId },\n    });\n  }\n});\n\n// Due date reminder\neventBus.on('task.updated', async ({ task, changes }) => {\n  if (changes.dueDate && task.assigneeId) {\n    await notifications.scheduleDueReminder(task);\n  }\n});\n```\n\n## Cache Invalidation\n\n```typescript\n// src/foundation/cache/invalidation.ts\nimport { eventBus } from '@/foundation/events';\nimport { cache } from './client';\n\n// Invalidate task cache on updates\neventBus.on('task.updated', async ({ task }) => {\n  await cache.del(`task:${task.id}`);\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.created', async ({ task }) => {\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.deleted', async ({ taskId, boardId }) => {\n  await cache.del(`task:${taskId}`);\n  await cache.del(`board:${boardId}:tasks`);\n});\n```\n\n## Singleton Instance\n\n```typescript\n// src/foundation/events/index.ts\nimport { EventBus } from './bus';\nimport { redis, redisSub } from '@/foundation/cache';\n\nexport const eventBus = new EventBus(redis, redisSub);\n\nexport * from './types';\n```\n\n## Used By\n\n- [c3-1.4: Events Bus](../c3-components.md#c3-14-events-bus)\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- All feature modules (publishing events)\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/event-bus.md",
        "content": "# Reference: Event Bus\n\n> Domain event publishing and subscription patterns\n\n## Overview\n\nThe event bus enables:\n- Loose coupling between modules\n- Cross-instance event broadcast via Redis\n- Extensibility for future integrations (webhooks, analytics)\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         Event Flow                               │\n│                                                                  │\n│  ┌──────────┐    publish     ┌───────────────┐                  │\n│  │  Module  │───────────────▶│   Event Bus   │                  │\n│  └──────────┘                └───────┬───────┘                  │\n│                                      │                          │\n│              ┌───────────────────────┼───────────────────────┐  │\n│              │                       │                       │  │\n│              ▼                       ▼                       ▼  │\n│     ┌────────────────┐     ┌────────────────┐     ┌───────────┐ │\n│     │  Local Handler │     │ Redis Pub/Sub  │     │  Handler  │ │\n│     │  (same process)│     │  (broadcast)   │     │  (other)  │ │\n│     └────────────────┘     └────────────────┘     └───────────┘ │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Implementation\n\n```typescript\n// src/foundation/events/bus.ts\nimport { EventEmitter } from 'eventemitter3';\nimport { Redis } from 'ioredis';\nimport { DomainEvent, EventHandler } from './types';\n\nexport class EventBus {\n  private emitter = new EventEmitter();\n  private redis: Redis;\n  private redisSub: Redis;\n  private channel = 'taskflow:events';\n\n  constructor(redis: Redis, redisSub: Redis) {\n    this.redis = redis;\n    this.redisSub = redisSub;\n    this.setupRedisSubscription();\n  }\n\n  /**\n   * Emit an event locally and broadcast via Redis\n   */\n  async emit<T extends DomainEvent>(\n    type: T['type'],\n    payload: T['payload'],\n    options: { broadcast?: boolean } = { broadcast: true }\n  ) {\n    const event = { type, payload, timestamp: Date.now() };\n\n    // Local handlers\n    this.emitter.emit(type, payload);\n\n    // Broadcast to other instances\n    if (options.broadcast) {\n      await this.redis.publish(this.channel, JSON.stringify(event));\n    }\n  }\n\n  /**\n   * Subscribe to an event type\n   */\n  on<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.on(type, handler);\n    return () => this.emitter.off(type, handler);\n  }\n\n  /**\n   * One-time subscription\n   */\n  once<T extends DomainEvent>(\n    type: T['type'],\n    handler: EventHandler<T['payload']>\n  ) {\n    this.emitter.once(type, handler);\n  }\n\n  private setupRedisSubscription() {\n    this.redisSub.subscribe(this.channel);\n\n    this.redisSub.on('message', (channel, message) => {\n      if (channel !== this.channel) return;\n\n      try {\n        const event = JSON.parse(message);\n        // Emit locally without re-broadcasting\n        this.emitter.emit(event.type, event.payload);\n      } catch (error) {\n        console.error('Failed to parse event:', error);\n      }\n    });\n  }\n}\n```\n\n## Event Types\n\n```typescript\n// src/foundation/events/types.ts\n\n// Task events\nexport interface TaskCreatedEvent {\n  type: 'task.created';\n  payload: { task: Task; userId: string };\n}\n\nexport interface TaskUpdatedEvent {\n  type: 'task.updated';\n  payload: { task: Task; userId: string; changes: Partial<Task> };\n}\n\nexport interface TaskMovedEvent {\n  type: 'task.moved';\n  payload: {\n    task: Task;\n    fromColumnId: string;\n    toColumnId: string;\n    userId: string;\n  };\n}\n\nexport interface TaskDeletedEvent {\n  type: 'task.deleted';\n  payload: { taskId: string; boardId: string; userId: string };\n}\n\nexport interface TaskAssignedEvent {\n  type: 'task.assigned';\n  payload: { taskId: string; assigneeId: string; assignedBy: string };\n}\n\n// Board events\nexport interface BoardUpdatedEvent {\n  type: 'board.updated';\n  payload: { board: Board; userId: string };\n}\n\nexport interface ColumnCreatedEvent {\n  type: 'column.created';\n  payload: { column: Column; boardId: string };\n}\n\nexport interface ColumnReorderedEvent {\n  type: 'column.reordered';\n  payload: { columns: Column[]; boardId: string };\n}\n\n// Workspace events\nexport interface UserJoinedWorkspaceEvent {\n  type: 'workspace.user_joined';\n  payload: { userId: string; workspaceId: string; role: string };\n}\n\n// Union type\nexport type DomainEvent =\n  | TaskCreatedEvent\n  | TaskUpdatedEvent\n  | TaskMovedEvent\n  | TaskDeletedEvent\n  | TaskAssignedEvent\n  | BoardUpdatedEvent\n  | ColumnCreatedEvent\n  | ColumnReorderedEvent\n  | UserJoinedWorkspaceEvent;\n\n// Handler type\nexport type EventHandler<T> = (payload: T) => void | Promise<void>;\n```\n\n## Usage in Modules\n\n### Publishing Events\n\n```typescript\n// src/modules/task/task.service.ts\nimport { eventBus } from '@/foundation/events';\n\nexport class TaskService {\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Publish domain event\n    await eventBus.emit('task.created', {\n      task,\n      userId: user.id,\n    });\n\n    return task;\n  }\n\n  async move(taskId: string, columnId: string, position: number, user: AuthUser) {\n    const task = await this.repo.findById(taskId);\n    const fromColumnId = task.columnId;\n\n    const updated = await this.repo.move(taskId, columnId, position);\n\n    await eventBus.emit('task.moved', {\n      task: updated,\n      fromColumnId,\n      toColumnId: columnId,\n      userId: user.id,\n    });\n\n    return updated;\n  }\n}\n```\n\n### Subscribing to Events\n\n```typescript\n// src/modules/notification/notification.listener.ts\nimport { eventBus } from '@/foundation/events';\nimport { NotificationService } from './notification.service';\n\nconst notifications = new NotificationService();\n\n// Task assignment notification\neventBus.on('task.assigned', async ({ taskId, assigneeId, assignedBy }) => {\n  if (assigneeId !== assignedBy) {\n    await notifications.create({\n      userId: assigneeId,\n      type: 'task_assigned',\n      title: 'New task assigned',\n      data: { taskId },\n    });\n  }\n});\n\n// Due date reminder\neventBus.on('task.updated', async ({ task, changes }) => {\n  if (changes.dueDate && task.assigneeId) {\n    await notifications.scheduleDueReminder(task);\n  }\n});\n```\n\n## Cache Invalidation\n\n```typescript\n// src/foundation/cache/invalidation.ts\nimport { eventBus } from '@/foundation/events';\nimport { cache } from './client';\n\n// Invalidate task cache on updates\neventBus.on('task.updated', async ({ task }) => {\n  await cache.del(`task:${task.id}`);\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.created', async ({ task }) => {\n  await cache.del(`board:${task.boardId}:tasks`);\n});\n\neventBus.on('task.deleted', async ({ taskId, boardId }) => {\n  await cache.del(`task:${taskId}`);\n  await cache.del(`board:${boardId}:tasks`);\n});\n```\n\n## Singleton Instance\n\n```typescript\n// src/foundation/events/index.ts\nimport { EventBus } from './bus';\nimport { redis, redisSub } from '@/foundation/cache';\n\nexport const eventBus = new EventBus(redis, redisSub);\n\nexport * from './types';\n```\n\n## Used By\n\n- [c3-1.4: Events Bus](../c3-components.md#c3-14-events-bus)\n- [c3-1.8: Realtime Module](../c3-components.md#c3-18-realtime-module)\n- All feature modules (publishing events)\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:32:34.653Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/cache-aside.md",
        "content": "# Reference: Cache-Aside Pattern\n\n> Read-through caching with Redis\n\n## Overview\n\nThe cache-aside pattern:\n1. Check cache first\n2. On miss, read from database\n3. Store result in cache\n4. Return data\n\n## Implementation\n\n```typescript\n// src/foundation/cache/client.ts\nimport Redis from 'ioredis';\n\nexport const redis = new Redis(process.env.REDIS_URL);\nexport const redisSub = new Redis(process.env.REDIS_URL); // For pub/sub\n\nexport const cache = {\n  async get<T>(key: string): Promise<T | null> {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : null;\n  },\n\n  async set<T>(key: string, value: T, ttlSeconds = 300): Promise<void> {\n    await redis.setex(key, ttlSeconds, JSON.stringify(value));\n  },\n\n  async del(key: string): Promise<void> {\n    await redis.del(key);\n  },\n\n  async delPattern(pattern: string): Promise<void> {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  },\n};\n```\n\n## Cache Keys\n\n```typescript\n// src/foundation/cache/keys.ts\n\nexport const cacheKeys = {\n  // User keys\n  user: (id: string) => `user:${id}`,\n  userWorkspaces: (userId: string) => `user:${userId}:workspaces`,\n\n  // Workspace keys\n  workspace: (id: string) => `workspace:${id}`,\n  workspaceMembers: (id: string) => `workspace:${id}:members`,\n\n  // Board keys\n  board: (id: string) => `board:${id}`,\n  boardTasks: (boardId: string) => `board:${boardId}:tasks`,\n  boardColumns: (boardId: string) => `board:${boardId}:columns`,\n\n  // Task keys\n  task: (id: string) => `task:${id}`,\n  taskComments: (taskId: string) => `task:${taskId}:comments`,\n\n  // Session keys\n  session: (token: string) => `session:${token}`,\n};\n```\n\n## Cache Decorator\n\n```typescript\n// src/foundation/cache/decorators.ts\nimport { cache, cacheKeys } from './client';\n\ninterface CacheOptions {\n  ttl?: number;\n  keyFn: (...args: any[]) => string;\n}\n\nexport function Cacheable(options: CacheOptions) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const key = options.keyFn(...args);\n\n      // Check cache\n      const cached = await cache.get(key);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Execute method\n      const result = await originalMethod.apply(this, args);\n\n      // Store in cache\n      if (result !== null && result !== undefined) {\n        await cache.set(key, result, options.ttl ?? 300);\n      }\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n\nexport function CacheInvalidate(keyFn: (...args: any[]) => string | string[]) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const result = await originalMethod.apply(this, args);\n\n      // Invalidate cache\n      const keys = keyFn(...args);\n      const keyArray = Array.isArray(keys) ? keys : [keys];\n\n      await Promise.all(keyArray.map(key => cache.del(key)));\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n```\n\n## Usage in Repository\n\n```typescript\n// src/modules/board/board.repository.ts\nimport { Cacheable, CacheInvalidate } from '@/foundation/cache';\nimport { cacheKeys } from '@/foundation/cache/keys';\n\nexport class BoardRepository extends TenantRepository<Board> {\n  @Cacheable({\n    keyFn: (id: string) => cacheKeys.board(id),\n    ttl: 600, // 10 minutes\n  })\n  async findById(id: string): Promise<Board | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  @Cacheable({\n    keyFn: (boardId: string) => cacheKeys.boardColumns(boardId),\n    ttl: 300,\n  })\n  async getColumns(boardId: string): Promise<Column[]> {\n    return this.db\n      .selectFrom('columns')\n      .where('board_id', '=', boardId)\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  @CacheInvalidate((id: string) => cacheKeys.board(id))\n  async update(id: string, data: UpdateBoardData): Promise<Board> {\n    return this.db\n      .updateTable('boards')\n      .set(data)\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n}\n```\n\n## Manual Cache Usage\n\n```typescript\n// src/modules/task/task.service.ts\nimport { cache, cacheKeys } from '@/foundation/cache';\n\nexport class TaskService {\n  async getByBoard(boardId: string): Promise<Task[]> {\n    const cacheKey = cacheKeys.boardTasks(boardId);\n\n    // Check cache\n    const cached = await cache.get<Task[]>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Load from DB\n    const tasks = await this.repo.findByBoard(boardId);\n\n    // Cache for 5 minutes\n    await cache.set(cacheKey, tasks, 300);\n\n    return tasks;\n  }\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Invalidate board tasks cache\n    await cache.del(cacheKeys.boardTasks(task.boardId));\n\n    return task;\n  }\n}\n```\n\n## TTL Guidelines\n\n| Data Type | TTL | Rationale |\n|-----------|-----|-----------|\n| User profile | 10 min | Rarely changes |\n| Workspace | 10 min | Rarely changes |\n| Board metadata | 5 min | Moderate change frequency |\n| Board tasks | 1 min | Changes often via real-time |\n| Session | 24 hours | Until expiry |\n\n## Cache Warming\n\n```typescript\n// src/foundation/cache/warming.ts\n\nexport async function warmBoardCache(boardId: string) {\n  const boardRepo = new BoardRepository(workspaceId);\n  const taskRepo = new TaskRepository(workspaceId);\n\n  // Parallel cache warming\n  await Promise.all([\n    boardRepo.findById(boardId), // Triggers @Cacheable\n    boardRepo.getColumns(boardId),\n    taskRepo.findByBoard(boardId),\n  ]);\n}\n```\n\n## Used By\n\n- [c3-1.3: Cache Layer](../c3-components.md#c3-13-cache-layer)\n- All repositories with caching\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:32:34.673Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/cache-aside.md",
        "content": "# Reference: Cache-Aside Pattern\n\n> Read-through caching with Redis\n\n## Overview\n\nThe cache-aside pattern:\n1. Check cache first\n2. On miss, read from database\n3. Store result in cache\n4. Return data\n\n## Implementation\n\n```typescript\n// src/foundation/cache/client.ts\nimport Redis from 'ioredis';\n\nexport const redis = new Redis(process.env.REDIS_URL);\nexport const redisSub = new Redis(process.env.REDIS_URL); // For pub/sub\n\nexport const cache = {\n  async get<T>(key: string): Promise<T | null> {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : null;\n  },\n\n  async set<T>(key: string, value: T, ttlSeconds = 300): Promise<void> {\n    await redis.setex(key, ttlSeconds, JSON.stringify(value));\n  },\n\n  async del(key: string): Promise<void> {\n    await redis.del(key);\n  },\n\n  async delPattern(pattern: string): Promise<void> {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  },\n};\n```\n\n## Cache Keys\n\n```typescript\n// src/foundation/cache/keys.ts\n\nexport const cacheKeys = {\n  // User keys\n  user: (id: string) => `user:${id}`,\n  userWorkspaces: (userId: string) => `user:${userId}:workspaces`,\n\n  // Workspace keys\n  workspace: (id: string) => `workspace:${id}`,\n  workspaceMembers: (id: string) => `workspace:${id}:members`,\n\n  // Board keys\n  board: (id: string) => `board:${id}`,\n  boardTasks: (boardId: string) => `board:${boardId}:tasks`,\n  boardColumns: (boardId: string) => `board:${boardId}:columns`,\n\n  // Task keys\n  task: (id: string) => `task:${id}`,\n  taskComments: (taskId: string) => `task:${taskId}:comments`,\n\n  // Session keys\n  session: (token: string) => `session:${token}`,\n};\n```\n\n## Cache Decorator\n\n```typescript\n// src/foundation/cache/decorators.ts\nimport { cache, cacheKeys } from './client';\n\ninterface CacheOptions {\n  ttl?: number;\n  keyFn: (...args: any[]) => string;\n}\n\nexport function Cacheable(options: CacheOptions) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const key = options.keyFn(...args);\n\n      // Check cache\n      const cached = await cache.get(key);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Execute method\n      const result = await originalMethod.apply(this, args);\n\n      // Store in cache\n      if (result !== null && result !== undefined) {\n        await cache.set(key, result, options.ttl ?? 300);\n      }\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n\nexport function CacheInvalidate(keyFn: (...args: any[]) => string | string[]) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const result = await originalMethod.apply(this, args);\n\n      // Invalidate cache\n      const keys = keyFn(...args);\n      const keyArray = Array.isArray(keys) ? keys : [keys];\n\n      await Promise.all(keyArray.map(key => cache.del(key)));\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n```\n\n## Usage in Repository\n\n```typescript\n// src/modules/board/board.repository.ts\nimport { Cacheable, CacheInvalidate } from '@/foundation/cache';\nimport { cacheKeys } from '@/foundation/cache/keys';\n\nexport class BoardRepository extends TenantRepository<Board> {\n  @Cacheable({\n    keyFn: (id: string) => cacheKeys.board(id),\n    ttl: 600, // 10 minutes\n  })\n  async findById(id: string): Promise<Board | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  @Cacheable({\n    keyFn: (boardId: string) => cacheKeys.boardColumns(boardId),\n    ttl: 300,\n  })\n  async getColumns(boardId: string): Promise<Column[]> {\n    return this.db\n      .selectFrom('columns')\n      .where('board_id', '=', boardId)\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  @CacheInvalidate((id: string) => cacheKeys.board(id))\n  async update(id: string, data: UpdateBoardData): Promise<Board> {\n    return this.db\n      .updateTable('boards')\n      .set(data)\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n}\n```\n\n## Manual Cache Usage\n\n```typescript\n// src/modules/task/task.service.ts\nimport { cache, cacheKeys } from '@/foundation/cache';\n\nexport class TaskService {\n  async getByBoard(boardId: string): Promise<Task[]> {\n    const cacheKey = cacheKeys.boardTasks(boardId);\n\n    // Check cache\n    const cached = await cache.get<Task[]>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Load from DB\n    const tasks = await this.repo.findByBoard(boardId);\n\n    // Cache for 5 minutes\n    await cache.set(cacheKey, tasks, 300);\n\n    return tasks;\n  }\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Invalidate board tasks cache\n    await cache.del(cacheKeys.boardTasks(task.boardId));\n\n    return task;\n  }\n}\n```\n\n## TTL Guidelines\n\n| Data Type | TTL | Rationale |\n|-----------|-----|-----------|\n| User profile | 10 min | Rarely changes |\n| Workspace | 10 min | Rarely changes |\n| Board metadata | 5 min | Moderate change frequency |\n| Board tasks | 1 min | Changes often via real-time |\n| Session | 24 hours | Until expiry |\n\n## Cache Warming\n\n```typescript\n// src/foundation/cache/warming.ts\n\nexport async function warmBoardCache(boardId: string) {\n  const boardRepo = new BoardRepository(workspaceId);\n  const taskRepo = new TaskRepository(workspaceId);\n\n  // Parallel cache warming\n  await Promise.all([\n    boardRepo.findById(boardId), // Triggers @Cacheable\n    boardRepo.getColumns(boardId),\n    taskRepo.findByBoard(boardId),\n  ]);\n}\n```\n\n## Used By\n\n- [c3-1.3: Cache Layer](../c3-components.md#c3-13-cache-layer)\n- All repositories with caching\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/cache-aside.md",
        "content": "# Reference: Cache-Aside Pattern\n\n> Read-through caching with Redis\n\n## Overview\n\nThe cache-aside pattern:\n1. Check cache first\n2. On miss, read from database\n3. Store result in cache\n4. Return data\n\n## Implementation\n\n```typescript\n// src/foundation/cache/client.ts\nimport Redis from 'ioredis';\n\nexport const redis = new Redis(process.env.REDIS_URL);\nexport const redisSub = new Redis(process.env.REDIS_URL); // For pub/sub\n\nexport const cache = {\n  async get<T>(key: string): Promise<T | null> {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : null;\n  },\n\n  async set<T>(key: string, value: T, ttlSeconds = 300): Promise<void> {\n    await redis.setex(key, ttlSeconds, JSON.stringify(value));\n  },\n\n  async del(key: string): Promise<void> {\n    await redis.del(key);\n  },\n\n  async delPattern(pattern: string): Promise<void> {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  },\n};\n```\n\n## Cache Keys\n\n```typescript\n// src/foundation/cache/keys.ts\n\nexport const cacheKeys = {\n  // User keys\n  user: (id: string) => `user:${id}`,\n  userWorkspaces: (userId: string) => `user:${userId}:workspaces`,\n\n  // Workspace keys\n  workspace: (id: string) => `workspace:${id}`,\n  workspaceMembers: (id: string) => `workspace:${id}:members`,\n\n  // Board keys\n  board: (id: string) => `board:${id}`,\n  boardTasks: (boardId: string) => `board:${boardId}:tasks`,\n  boardColumns: (boardId: string) => `board:${boardId}:columns`,\n\n  // Task keys\n  task: (id: string) => `task:${id}`,\n  taskComments: (taskId: string) => `task:${taskId}:comments`,\n\n  // Session keys\n  session: (token: string) => `session:${token}`,\n};\n```\n\n## Cache Decorator\n\n```typescript\n// src/foundation/cache/decorators.ts\nimport { cache, cacheKeys } from './client';\n\ninterface CacheOptions {\n  ttl?: number;\n  keyFn: (...args: any[]) => string;\n}\n\nexport function Cacheable(options: CacheOptions) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const key = options.keyFn(...args);\n\n      // Check cache\n      const cached = await cache.get(key);\n      if (cached !== null) {\n        return cached;\n      }\n\n      // Execute method\n      const result = await originalMethod.apply(this, args);\n\n      // Store in cache\n      if (result !== null && result !== undefined) {\n        await cache.set(key, result, options.ttl ?? 300);\n      }\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n\nexport function CacheInvalidate(keyFn: (...args: any[]) => string | string[]) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const result = await originalMethod.apply(this, args);\n\n      // Invalidate cache\n      const keys = keyFn(...args);\n      const keyArray = Array.isArray(keys) ? keys : [keys];\n\n      await Promise.all(keyArray.map(key => cache.del(key)));\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n```\n\n## Usage in Repository\n\n```typescript\n// src/modules/board/board.repository.ts\nimport { Cacheable, CacheInvalidate } from '@/foundation/cache';\nimport { cacheKeys } from '@/foundation/cache/keys';\n\nexport class BoardRepository extends TenantRepository<Board> {\n  @Cacheable({\n    keyFn: (id: string) => cacheKeys.board(id),\n    ttl: 600, // 10 minutes\n  })\n  async findById(id: string): Promise<Board | null> {\n    return this.scoped()\n      .where('id', '=', id)\n      .selectAll()\n      .executeTakeFirst() ?? null;\n  }\n\n  @Cacheable({\n    keyFn: (boardId: string) => cacheKeys.boardColumns(boardId),\n    ttl: 300,\n  })\n  async getColumns(boardId: string): Promise<Column[]> {\n    return this.db\n      .selectFrom('columns')\n      .where('board_id', '=', boardId)\n      .orderBy('position')\n      .selectAll()\n      .execute();\n  }\n\n  @CacheInvalidate((id: string) => cacheKeys.board(id))\n  async update(id: string, data: UpdateBoardData): Promise<Board> {\n    return this.db\n      .updateTable('boards')\n      .set(data)\n      .where('id', '=', id)\n      .returningAll()\n      .executeTakeFirstOrThrow();\n  }\n}\n```\n\n## Manual Cache Usage\n\n```typescript\n// src/modules/task/task.service.ts\nimport { cache, cacheKeys } from '@/foundation/cache';\n\nexport class TaskService {\n  async getByBoard(boardId: string): Promise<Task[]> {\n    const cacheKey = cacheKeys.boardTasks(boardId);\n\n    // Check cache\n    const cached = await cache.get<Task[]>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    // Load from DB\n    const tasks = await this.repo.findByBoard(boardId);\n\n    // Cache for 5 minutes\n    await cache.set(cacheKey, tasks, 300);\n\n    return tasks;\n  }\n\n  async create(input: CreateTaskInput, user: AuthUser): Promise<Task> {\n    const task = await this.repo.create(input);\n\n    // Invalidate board tasks cache\n    await cache.del(cacheKeys.boardTasks(task.boardId));\n\n    return task;\n  }\n}\n```\n\n## TTL Guidelines\n\n| Data Type | TTL | Rationale |\n|-----------|-----|-----------|\n| User profile | 10 min | Rarely changes |\n| Workspace | 10 min | Rarely changes |\n| Board metadata | 5 min | Moderate change frequency |\n| Board tasks | 1 min | Changes often via real-time |\n| Session | 24 hours | Until expiry |\n\n## Cache Warming\n\n```typescript\n// src/foundation/cache/warming.ts\n\nexport async function warmBoardCache(boardId: string) {\n  const boardRepo = new BoardRepository(workspaceId);\n  const taskRepo = new TaskRepository(workspaceId);\n\n  // Parallel cache warming\n  await Promise.all([\n    boardRepo.findById(boardId), // Triggers @Cacheable\n    boardRepo.getColumns(boardId),\n    taskRepo.findByBoard(boardId),\n  ]);\n}\n```\n\n## Used By\n\n- [c3-1.3: Cache Layer](../c3-components.md#c3-13-cache-layer)\n- All repositories with caching\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:33:01.001Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/express-setup.md",
        "content": "# Reference: Express Setup\n\n> Application bootstrap and middleware configuration\n\n## Overview\n\nThe HTTP core provides:\n- Express application factory\n- Global middleware pipeline\n- Error handling\n- Health checks\n\n## Application Factory\n\n```typescript\n// src/foundation/http/app.ts\nimport express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport { requestLogger } from './middleware/logging';\nimport { errorHandler } from './errors/handler';\nimport { rateLimiter } from './middleware/rate-limit';\n\nexport function createApp(): Application {\n  const app = express();\n\n  // Security middleware\n  app.use(helmet());\n  app.use(cors({\n    origin: process.env.CLIENT_URL,\n    credentials: true,\n  }));\n\n  // Body parsing\n  app.use(express.json({ limit: '10kb' }));\n  app.use(express.urlencoded({ extended: true }));\n\n  // Compression\n  app.use(compression());\n\n  // Logging\n  app.use(requestLogger);\n\n  // Rate limiting\n  app.use(rateLimiter);\n\n  // Health check (no auth)\n  app.get('/health', (req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  return app;\n}\n```\n\n## Server Bootstrap\n\n```typescript\n// src/main.ts\nimport http from 'http';\nimport { createApp } from './foundation/http/app';\nimport { registerRoutes } from './routes';\nimport { RealtimeGateway } from './modules/realtime';\nimport { setupEventBridge } from './modules/realtime/event-bridge';\nimport { db } from './foundation/db';\nimport { redis } from './foundation/cache';\n\nasync function bootstrap() {\n  // Create Express app\n  const app = createApp();\n\n  // Register API routes\n  registerRoutes(app);\n\n  // Create HTTP server\n  const server = http.createServer(app);\n\n  // Initialize WebSocket\n  const realtime = new RealtimeGateway(server);\n  setupEventBridge(realtime);\n\n  // Start server\n  const port = process.env.PORT || 3000;\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n\n  // Graceful shutdown\n  process.on('SIGTERM', async () => {\n    console.log('SIGTERM received, shutting down...');\n    server.close();\n    await db.destroy();\n    redis.disconnect();\n    process.exit(0);\n  });\n}\n\nbootstrap().catch(console.error);\n```\n\n## Route Registration\n\n```typescript\n// src/routes.ts\nimport { Application } from 'express';\nimport { authController } from './foundation/auth';\nimport { userController } from './modules/user';\nimport { workspaceController } from './modules/workspace';\nimport { boardController } from './modules/board';\nimport { taskController } from './modules/task';\nimport { errorHandler } from './foundation/http/errors/handler';\n\nexport function registerRoutes(app: Application) {\n  // API version prefix\n  const api = '/api/v1';\n\n  // Auth routes (public)\n  app.use(`${api}/auth`, authController);\n\n  // Protected routes\n  app.use(`${api}/users`, userController);\n  app.use(`${api}/workspaces`, workspaceController);\n  app.use(`${api}/boards`, boardController);\n  app.use(`${api}/tasks`, taskController);\n\n  // 404 handler\n  app.use((req, res) => {\n    res.status(404).json({ error: 'Not found' });\n  });\n\n  // Global error handler (must be last)\n  app.use(errorHandler);\n}\n```\n\n## Request Logging\n\n```typescript\n// src/foundation/http/middleware/logging.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\nexport function requestLogger(req: Request, res: Response, next: NextFunction) {\n  const requestId = randomUUID();\n  const start = Date.now();\n\n  // Attach request ID\n  req.headers['x-request-id'] = requestId;\n  res.setHeader('x-request-id', requestId);\n\n  // Log on response finish\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(JSON.stringify({\n      requestId,\n      method: req.method,\n      path: req.path,\n      status: res.statusCode,\n      duration,\n      userId: (req as any).user?.id,\n    }));\n  });\n\n  next();\n}\n```\n\n## Rate Limiting\n\n```typescript\n// src/foundation/http/middleware/rate-limit.ts\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport { redis } from '@/foundation/cache';\n\nexport const rateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 60 * 1000, // 1 minute\n  max: 100, // 100 requests per minute\n  message: { error: 'Too many requests, please try again later' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Stricter limit for auth endpoints\nexport const authRateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // 10 attempts\n  message: { error: 'Too many authentication attempts' },\n});\n```\n\n## Error Classes\n\n```typescript\n// src/foundation/http/errors/AppError.ts\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message = 'Forbidden') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(public errors: Record<string, string[]>) {\n    super('Validation failed', 400, 'VALIDATION_ERROR');\n  }\n}\n```\n\n## Error Handler\n\n```typescript\n// src/foundation/http/errors/handler.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\nimport { AppError, ValidationError } from './AppError';\n\nexport function errorHandler(\n  err: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Zod validation errors\n  if (err instanceof ZodError) {\n    const errors: Record<string, string[]> = {};\n    err.errors.forEach(e => {\n      const path = e.path.join('.');\n      errors[path] = errors[path] || [];\n      errors[path].push(e.message);\n    });\n\n    return res.status(400).json({\n      error: 'Validation failed',\n      code: 'VALIDATION_ERROR',\n      details: errors,\n    });\n  }\n\n  // Custom app errors\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: err.message,\n      code: err.code,\n      ...(err instanceof ValidationError && { details: err.errors }),\n    });\n  }\n\n  // Unknown errors\n  console.error('Unhandled error:', err);\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR',\n  });\n}\n```\n\n## Used By\n\n- [c3-1.0: HTTP Core](../c3-components.md#c3-10-http-core)\n- Application entry point (`src/main.ts`)\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:33:01.022Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/refs/express-setup.md",
        "content": "# Reference: Express Setup\n\n> Application bootstrap and middleware configuration\n\n## Overview\n\nThe HTTP core provides:\n- Express application factory\n- Global middleware pipeline\n- Error handling\n- Health checks\n\n## Application Factory\n\n```typescript\n// src/foundation/http/app.ts\nimport express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport { requestLogger } from './middleware/logging';\nimport { errorHandler } from './errors/handler';\nimport { rateLimiter } from './middleware/rate-limit';\n\nexport function createApp(): Application {\n  const app = express();\n\n  // Security middleware\n  app.use(helmet());\n  app.use(cors({\n    origin: process.env.CLIENT_URL,\n    credentials: true,\n  }));\n\n  // Body parsing\n  app.use(express.json({ limit: '10kb' }));\n  app.use(express.urlencoded({ extended: true }));\n\n  // Compression\n  app.use(compression());\n\n  // Logging\n  app.use(requestLogger);\n\n  // Rate limiting\n  app.use(rateLimiter);\n\n  // Health check (no auth)\n  app.get('/health', (req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  return app;\n}\n```\n\n## Server Bootstrap\n\n```typescript\n// src/main.ts\nimport http from 'http';\nimport { createApp } from './foundation/http/app';\nimport { registerRoutes } from './routes';\nimport { RealtimeGateway } from './modules/realtime';\nimport { setupEventBridge } from './modules/realtime/event-bridge';\nimport { db } from './foundation/db';\nimport { redis } from './foundation/cache';\n\nasync function bootstrap() {\n  // Create Express app\n  const app = createApp();\n\n  // Register API routes\n  registerRoutes(app);\n\n  // Create HTTP server\n  const server = http.createServer(app);\n\n  // Initialize WebSocket\n  const realtime = new RealtimeGateway(server);\n  setupEventBridge(realtime);\n\n  // Start server\n  const port = process.env.PORT || 3000;\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n\n  // Graceful shutdown\n  process.on('SIGTERM', async () => {\n    console.log('SIGTERM received, shutting down...');\n    server.close();\n    await db.destroy();\n    redis.disconnect();\n    process.exit(0);\n  });\n}\n\nbootstrap().catch(console.error);\n```\n\n## Route Registration\n\n```typescript\n// src/routes.ts\nimport { Application } from 'express';\nimport { authController } from './foundation/auth';\nimport { userController } from './modules/user';\nimport { workspaceController } from './modules/workspace';\nimport { boardController } from './modules/board';\nimport { taskController } from './modules/task';\nimport { errorHandler } from './foundation/http/errors/handler';\n\nexport function registerRoutes(app: Application) {\n  // API version prefix\n  const api = '/api/v1';\n\n  // Auth routes (public)\n  app.use(`${api}/auth`, authController);\n\n  // Protected routes\n  app.use(`${api}/users`, userController);\n  app.use(`${api}/workspaces`, workspaceController);\n  app.use(`${api}/boards`, boardController);\n  app.use(`${api}/tasks`, taskController);\n\n  // 404 handler\n  app.use((req, res) => {\n    res.status(404).json({ error: 'Not found' });\n  });\n\n  // Global error handler (must be last)\n  app.use(errorHandler);\n}\n```\n\n## Request Logging\n\n```typescript\n// src/foundation/http/middleware/logging.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\nexport function requestLogger(req: Request, res: Response, next: NextFunction) {\n  const requestId = randomUUID();\n  const start = Date.now();\n\n  // Attach request ID\n  req.headers['x-request-id'] = requestId;\n  res.setHeader('x-request-id', requestId);\n\n  // Log on response finish\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(JSON.stringify({\n      requestId,\n      method: req.method,\n      path: req.path,\n      status: res.statusCode,\n      duration,\n      userId: (req as any).user?.id,\n    }));\n  });\n\n  next();\n}\n```\n\n## Rate Limiting\n\n```typescript\n// src/foundation/http/middleware/rate-limit.ts\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport { redis } from '@/foundation/cache';\n\nexport const rateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 60 * 1000, // 1 minute\n  max: 100, // 100 requests per minute\n  message: { error: 'Too many requests, please try again later' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Stricter limit for auth endpoints\nexport const authRateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // 10 attempts\n  message: { error: 'Too many authentication attempts' },\n});\n```\n\n## Error Classes\n\n```typescript\n// src/foundation/http/errors/AppError.ts\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message = 'Forbidden') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(public errors: Record<string, string[]>) {\n    super('Validation failed', 400, 'VALIDATION_ERROR');\n  }\n}\n```\n\n## Error Handler\n\n```typescript\n// src/foundation/http/errors/handler.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\nimport { AppError, ValidationError } from './AppError';\n\nexport function errorHandler(\n  err: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Zod validation errors\n  if (err instanceof ZodError) {\n    const errors: Record<string, string[]> = {};\n    err.errors.forEach(e => {\n      const path = e.path.join('.');\n      errors[path] = errors[path] || [];\n      errors[path].push(e.message);\n    });\n\n    return res.status(400).json({\n      error: 'Validation failed',\n      code: 'VALIDATION_ERROR',\n      details: errors,\n    });\n  }\n\n  // Custom app errors\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: err.message,\n      code: err.code,\n      ...(err instanceof ValidationError && { details: err.errors }),\n    });\n  }\n\n  // Unknown errors\n  console.error('Unhandled error:', err);\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR',\n  });\n}\n```\n\n## Used By\n\n- [c3-1.0: HTTP Core](../c3-components.md#c3-10-http-core)\n- Application entry point (`src/main.ts`)\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/refs/express-setup.md",
        "content": "# Reference: Express Setup\n\n> Application bootstrap and middleware configuration\n\n## Overview\n\nThe HTTP core provides:\n- Express application factory\n- Global middleware pipeline\n- Error handling\n- Health checks\n\n## Application Factory\n\n```typescript\n// src/foundation/http/app.ts\nimport express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport { requestLogger } from './middleware/logging';\nimport { errorHandler } from './errors/handler';\nimport { rateLimiter } from './middleware/rate-limit';\n\nexport function createApp(): Application {\n  const app = express();\n\n  // Security middleware\n  app.use(helmet());\n  app.use(cors({\n    origin: process.env.CLIENT_URL,\n    credentials: true,\n  }));\n\n  // Body parsing\n  app.use(express.json({ limit: '10kb' }));\n  app.use(express.urlencoded({ extended: true }));\n\n  // Compression\n  app.use(compression());\n\n  // Logging\n  app.use(requestLogger);\n\n  // Rate limiting\n  app.use(rateLimiter);\n\n  // Health check (no auth)\n  app.get('/health', (req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  return app;\n}\n```\n\n## Server Bootstrap\n\n```typescript\n// src/main.ts\nimport http from 'http';\nimport { createApp } from './foundation/http/app';\nimport { registerRoutes } from './routes';\nimport { RealtimeGateway } from './modules/realtime';\nimport { setupEventBridge } from './modules/realtime/event-bridge';\nimport { db } from './foundation/db';\nimport { redis } from './foundation/cache';\n\nasync function bootstrap() {\n  // Create Express app\n  const app = createApp();\n\n  // Register API routes\n  registerRoutes(app);\n\n  // Create HTTP server\n  const server = http.createServer(app);\n\n  // Initialize WebSocket\n  const realtime = new RealtimeGateway(server);\n  setupEventBridge(realtime);\n\n  // Start server\n  const port = process.env.PORT || 3000;\n  server.listen(port, () => {\n    console.log(`Server running on port ${port}`);\n  });\n\n  // Graceful shutdown\n  process.on('SIGTERM', async () => {\n    console.log('SIGTERM received, shutting down...');\n    server.close();\n    await db.destroy();\n    redis.disconnect();\n    process.exit(0);\n  });\n}\n\nbootstrap().catch(console.error);\n```\n\n## Route Registration\n\n```typescript\n// src/routes.ts\nimport { Application } from 'express';\nimport { authController } from './foundation/auth';\nimport { userController } from './modules/user';\nimport { workspaceController } from './modules/workspace';\nimport { boardController } from './modules/board';\nimport { taskController } from './modules/task';\nimport { errorHandler } from './foundation/http/errors/handler';\n\nexport function registerRoutes(app: Application) {\n  // API version prefix\n  const api = '/api/v1';\n\n  // Auth routes (public)\n  app.use(`${api}/auth`, authController);\n\n  // Protected routes\n  app.use(`${api}/users`, userController);\n  app.use(`${api}/workspaces`, workspaceController);\n  app.use(`${api}/boards`, boardController);\n  app.use(`${api}/tasks`, taskController);\n\n  // 404 handler\n  app.use((req, res) => {\n    res.status(404).json({ error: 'Not found' });\n  });\n\n  // Global error handler (must be last)\n  app.use(errorHandler);\n}\n```\n\n## Request Logging\n\n```typescript\n// src/foundation/http/middleware/logging.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { randomUUID } from 'crypto';\n\nexport function requestLogger(req: Request, res: Response, next: NextFunction) {\n  const requestId = randomUUID();\n  const start = Date.now();\n\n  // Attach request ID\n  req.headers['x-request-id'] = requestId;\n  res.setHeader('x-request-id', requestId);\n\n  // Log on response finish\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(JSON.stringify({\n      requestId,\n      method: req.method,\n      path: req.path,\n      status: res.statusCode,\n      duration,\n      userId: (req as any).user?.id,\n    }));\n  });\n\n  next();\n}\n```\n\n## Rate Limiting\n\n```typescript\n// src/foundation/http/middleware/rate-limit.ts\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport { redis } from '@/foundation/cache';\n\nexport const rateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 60 * 1000, // 1 minute\n  max: 100, // 100 requests per minute\n  message: { error: 'Too many requests, please try again later' },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Stricter limit for auth endpoints\nexport const authRateLimiter = rateLimit({\n  store: new RedisStore({\n    sendCommand: (...args: string[]) => redis.call(...args),\n  }),\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // 10 attempts\n  message: { error: 'Too many authentication attempts' },\n});\n```\n\n## Error Classes\n\n```typescript\n// src/foundation/http/errors/AppError.ts\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public code?: string\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message = 'Forbidden') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(public errors: Record<string, string[]>) {\n    super('Validation failed', 400, 'VALIDATION_ERROR');\n  }\n}\n```\n\n## Error Handler\n\n```typescript\n// src/foundation/http/errors/handler.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { ZodError } from 'zod';\nimport { AppError, ValidationError } from './AppError';\n\nexport function errorHandler(\n  err: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  // Zod validation errors\n  if (err instanceof ZodError) {\n    const errors: Record<string, string[]> = {};\n    err.errors.forEach(e => {\n      const path = e.path.join('.');\n      errors[path] = errors[path] || [];\n      errors[path].push(e.message);\n    });\n\n    return res.status(400).json({\n      error: 'Validation failed',\n      code: 'VALIDATION_ERROR',\n      details: errors,\n    });\n  }\n\n  // Custom app errors\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: err.message,\n      code: err.code,\n      ...(err instanceof ValidationError && { details: err.errors }),\n    });\n  }\n\n  // Unknown errors\n  console.error('Unhandled error:', err);\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR',\n  });\n}\n```\n\n## Used By\n\n- [c3-1.0: HTTP Core](../c3-components.md#c3-10-http-core)\n- Application entry point (`src/main.ts`)\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:33:19.439Z",
      "event": "PreToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/README.md",
        "content": "# TaskFlow Architecture (C3)\n\n> Task management SaaS for small teams with real-time collaboration\n\n## Quick Navigation\n\n### Diagrams\n\n| Level | Document | Description |\n|-------|----------|-------------|\n| Context | [c3-context.md](./c3-context.md) | System boundary and external actors |\n| Container | [c3-containers.md](./c3-containers.md) | Deployable units (SPA, API, DB, Redis) |\n| Component | [c3-components.md](./c3-components.md) | Internal structure (Foundation + Features) |\n\n### Architecture Decisions\n\n| ADR | Title | Status |\n|-----|-------|--------|\n| [ADR-000](./adrs/adr-000.md) | System Blueprint | Accepted |\n\n### Reference Patterns\n\n| Pattern | Description |\n|---------|-------------|\n| [module-structure](./refs/module-structure.md) | Standard feature module layout |\n| [auth-middleware](./refs/auth-middleware.md) | Authentication & authorization |\n| [repository-pattern](./refs/repository-pattern.md) | Data access with Kysely |\n| [websocket-handler](./refs/websocket-handler.md) | Real-time WebSocket patterns |\n| [event-bus](./refs/event-bus.md) | Domain event publishing |\n| [cache-aside](./refs/cache-aside.md) | Redis caching patterns |\n| [express-setup](./refs/express-setup.md) | HTTP server configuration |\n\n## Component Index\n\n### API Server (c3-1)\n\n**Foundation Layer:**\n- `c3-1.0` HTTP Core - Express setup, middleware, errors\n- `c3-1.1` Auth Guard - Google OAuth, JWT, RBAC\n- `c3-1.2` DB Client - PostgreSQL with Kysely\n- `c3-1.3` Cache Layer - Redis caching\n- `c3-1.4` Events Bus - Domain events, Redis pub/sub\n\n**Feature Modules:**\n- `c3-1.5` Workspace Module - Teams, members, roles\n- `c3-1.6` Board Module - Kanban boards, columns\n- `c3-1.7` Task Module - Tasks, assignments, comments\n- `c3-1.8` Realtime Module - WebSocket, presence\n- `c3-1.9` User Module - Profiles, preferences\n\n### Web Application (c3-0)\n\n**Foundation:**\n- `c3-0.0` API Client - Axios wrapper\n- `c3-0.1` Auth Context - OAuth flow, tokens\n- `c3-0.2` State Store - React Query + Zustand\n- `c3-0.3` Realtime Client - WebSocket manager\n\n**Features:**\n- `c3-0.4` Board Feature - Board views\n- `c3-0.5` Task Feature - Task components\n- `c3-0.6` Workspace Feature - Workspace settings\n\n## Technology Stack\n\n| Layer | Technology |\n|-------|------------|\n| Frontend | React 18, TypeScript, Vite |\n| Backend | Node.js, Express, TypeScript |\n| Database | PostgreSQL 15+ |\n| Cache | Redis 7+ |\n| Auth | Google OAuth, JWT |\n| Real-time | Socket.IO |\n\n## Getting Started\n\n```bash\n# Prerequisites\nnode >= 20\npnpm >= 8\ndocker (for local postgres/redis)\n\n# Setup\npnpm install\ndocker-compose up -d\npnpm db:migrate\npnpm dev\n```\n\n---\n\n*Generated with C3 methodology*\n"
      }
    },
    {
      "timestamp": "2026-01-12T12:33:19.459Z",
      "event": "PostToolUse",
      "tool": "Write",
      "input": {
        "file_path": "/tmp/tmp.gWJkWnuCWD/.c3/README.md",
        "content": "# TaskFlow Architecture (C3)\n\n> Task management SaaS for small teams with real-time collaboration\n\n## Quick Navigation\n\n### Diagrams\n\n| Level | Document | Description |\n|-------|----------|-------------|\n| Context | [c3-context.md](./c3-context.md) | System boundary and external actors |\n| Container | [c3-containers.md](./c3-containers.md) | Deployable units (SPA, API, DB, Redis) |\n| Component | [c3-components.md](./c3-components.md) | Internal structure (Foundation + Features) |\n\n### Architecture Decisions\n\n| ADR | Title | Status |\n|-----|-------|--------|\n| [ADR-000](./adrs/adr-000.md) | System Blueprint | Accepted |\n\n### Reference Patterns\n\n| Pattern | Description |\n|---------|-------------|\n| [module-structure](./refs/module-structure.md) | Standard feature module layout |\n| [auth-middleware](./refs/auth-middleware.md) | Authentication & authorization |\n| [repository-pattern](./refs/repository-pattern.md) | Data access with Kysely |\n| [websocket-handler](./refs/websocket-handler.md) | Real-time WebSocket patterns |\n| [event-bus](./refs/event-bus.md) | Domain event publishing |\n| [cache-aside](./refs/cache-aside.md) | Redis caching patterns |\n| [express-setup](./refs/express-setup.md) | HTTP server configuration |\n\n## Component Index\n\n### API Server (c3-1)\n\n**Foundation Layer:**\n- `c3-1.0` HTTP Core - Express setup, middleware, errors\n- `c3-1.1` Auth Guard - Google OAuth, JWT, RBAC\n- `c3-1.2` DB Client - PostgreSQL with Kysely\n- `c3-1.3` Cache Layer - Redis caching\n- `c3-1.4` Events Bus - Domain events, Redis pub/sub\n\n**Feature Modules:**\n- `c3-1.5` Workspace Module - Teams, members, roles\n- `c3-1.6` Board Module - Kanban boards, columns\n- `c3-1.7` Task Module - Tasks, assignments, comments\n- `c3-1.8` Realtime Module - WebSocket, presence\n- `c3-1.9` User Module - Profiles, preferences\n\n### Web Application (c3-0)\n\n**Foundation:**\n- `c3-0.0` API Client - Axios wrapper\n- `c3-0.1` Auth Context - OAuth flow, tokens\n- `c3-0.2` State Store - React Query + Zustand\n- `c3-0.3` Realtime Client - WebSocket manager\n\n**Features:**\n- `c3-0.4` Board Feature - Board views\n- `c3-0.5` Task Feature - Task components\n- `c3-0.6` Workspace Feature - Workspace settings\n\n## Technology Stack\n\n| Layer | Technology |\n|-------|------------|\n| Frontend | React 18, TypeScript, Vite |\n| Backend | Node.js, Express, TypeScript |\n| Database | PostgreSQL 15+ |\n| Cache | Redis 7+ |\n| Auth | Google OAuth, JWT |\n| Real-time | Socket.IO |\n\n## Getting Started\n\n```bash\n# Prerequisites\nnode >= 20\npnpm >= 8\ndocker (for local postgres/redis)\n\n# Setup\npnpm install\ndocker-compose up -d\npnpm db:migrate\npnpm dev\n```\n\n---\n\n*Generated with C3 methodology*\n"
      },
      "result": {
        "type": "create",
        "filePath": "/tmp/tmp.gWJkWnuCWD/.c3/README.md",
        "content": "# TaskFlow Architecture (C3)\n\n> Task management SaaS for small teams with real-time collaboration\n\n## Quick Navigation\n\n### Diagrams\n\n| Level | Document | Description |\n|-------|----------|-------------|\n| Context | [c3-context.md](./c3-context.md) | System boundary and external actors |\n| Container | [c3-containers.md](./c3-containers.md) | Deployable units (SPA, API, DB, Redis) |\n| Component | [c3-components.md](./c3-components.md) | Internal structure (Foundation + Features) |\n\n### Architecture Decisions\n\n| ADR | Title | Status |\n|-----|-------|--------|\n| [ADR-000](./adrs/adr-000.md) | System Blueprint | Accepted |\n\n### Reference Patterns\n\n| Pattern | Description |\n|---------|-------------|\n| [module-structure](./refs/module-structure.md) | Standard feature module layout |\n| [auth-middleware](./refs/auth-middleware.md) | Authentication & authorization |\n| [repository-pattern](./refs/repository-pattern.md) | Data access with Kysely |\n| [websocket-handler](./refs/websocket-handler.md) | Real-time WebSocket patterns |\n| [event-bus](./refs/event-bus.md) | Domain event publishing |\n| [cache-aside](./refs/cache-aside.md) | Redis caching patterns |\n| [express-setup](./refs/express-setup.md) | HTTP server configuration |\n\n## Component Index\n\n### API Server (c3-1)\n\n**Foundation Layer:**\n- `c3-1.0` HTTP Core - Express setup, middleware, errors\n- `c3-1.1` Auth Guard - Google OAuth, JWT, RBAC\n- `c3-1.2` DB Client - PostgreSQL with Kysely\n- `c3-1.3` Cache Layer - Redis caching\n- `c3-1.4` Events Bus - Domain events, Redis pub/sub\n\n**Feature Modules:**\n- `c3-1.5` Workspace Module - Teams, members, roles\n- `c3-1.6` Board Module - Kanban boards, columns\n- `c3-1.7` Task Module - Tasks, assignments, comments\n- `c3-1.8` Realtime Module - WebSocket, presence\n- `c3-1.9` User Module - Profiles, preferences\n\n### Web Application (c3-0)\n\n**Foundation:**\n- `c3-0.0` API Client - Axios wrapper\n- `c3-0.1` Auth Context - OAuth flow, tokens\n- `c3-0.2` State Store - React Query + Zustand\n- `c3-0.3` Realtime Client - WebSocket manager\n\n**Features:**\n- `c3-0.4` Board Feature - Board views\n- `c3-0.5` Task Feature - Task components\n- `c3-0.6` Workspace Feature - Workspace settings\n\n## Technology Stack\n\n| Layer | Technology |\n|-------|------------|\n| Frontend | React 18, TypeScript, Vite |\n| Backend | Node.js, Express, TypeScript |\n| Database | PostgreSQL 15+ |\n| Cache | Redis 7+ |\n| Auth | Google OAuth, JWT |\n| Real-time | Socket.IO |\n\n## Getting Started\n\n```bash\n# Prerequisites\nnode >= 20\npnpm >= 8\ndocker (for local postgres/redis)\n\n# Setup\npnpm install\ndocker-compose up -d\npnpm db:migrate\npnpm dev\n```\n\n---\n\n*Generated with C3 methodology*\n",
        "structuredPatch": [],
        "originalFile": null
      }
    },
    {
      "timestamp": "2026-01-12T12:33:23.005Z",
      "event": "PreToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "completed",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:33:23.023Z",
      "event": "PostToolUse",
      "tool": "TodoWrite",
      "input": {
        "todos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "completed",
            "activeForm": "Creating C3 refs"
          }
        ]
      },
      "result": {
        "oldTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "in_progress",
            "activeForm": "Creating C3 refs"
          }
        ],
        "newTodos": [
          {
            "content": "Create C3 Context diagram (system boundary)",
            "status": "completed",
            "activeForm": "Creating C3 Context diagram"
          },
          {
            "content": "Create C3 Container diagram (deployable units)",
            "status": "completed",
            "activeForm": "Creating C3 Container diagram"
          },
          {
            "content": "Create C3 Component diagrams (Foundation + Feature)",
            "status": "completed",
            "activeForm": "Creating C3 Component diagrams"
          },
          {
            "content": "Create ADR-000 (Blueprint ADR)",
            "status": "completed",
            "activeForm": "Creating ADR-000 Blueprint"
          },
          {
            "content": "Create C3 refs (shared patterns)",
            "status": "completed",
            "activeForm": "Creating C3 refs"
          }
        ]
      }
    },
    {
      "timestamp": "2026-01-12T12:33:25.770Z",
      "event": "PreToolUse",
      "tool": "Bash",
      "input": {
        "command": "find .c3 -type f -name \"*.md\" | head -20",
        "description": "List all created C3 documentation files"
      }
    },
    {
      "timestamp": "2026-01-12T12:33:25.796Z",
      "event": "PostToolUse",
      "tool": "Bash",
      "input": {
        "command": "find .c3 -type f -name \"*.md\" | head -20",
        "description": "List all created C3 documentation files"
      },
      "result": {
        "stdout": ".c3/c3-components.md\n.c3/c3-context.md\n.c3/README.md\n.c3/refs/event-bus.md\n.c3/refs/express-setup.md\n.c3/refs/module-structure.md\n.c3/refs/repository-pattern.md\n.c3/refs/cache-aside.md\n.c3/refs/auth-middleware.md\n.c3/refs/websocket-handler.md\n.c3/c3-containers.md\n.c3/adrs/adr-000.md",
        "stderr": "",
        "interrupted": false,
        "isImage": false
      }
    }
  ],
  "judgment": {
    "pass": true,
    "score": 100,
    "expectations": [
      {
        "text": "ADR-000 exists and serves as the architectural blueprint",
        "pass": true,
        "reasoning": "ADR-000 exists at .c3/adrs/adr-000.md with comprehensive content including technology stack, architecture style (modular monolith), multi-tenancy strategy, real-time architecture, API design, security layers, implementation phases, and references to other documents. It clearly serves as the foundational blueprint."
      },
      {
        "text": "Context README describes TaskFlow's purpose and high-level architecture",
        "pass": true,
        "reasoning": "The .c3/README.md file clearly describes TaskFlow as 'Task management SaaS for small teams with real-time collaboration' and provides a comprehensive overview including navigation to diagrams, ADRs, reference patterns, component index, and technology stack. The c3-context.md also describes the system boundary, actors, and purpose."
      },
      {
        "text": "At least 3 containers are defined (frontend, API, database or similar)",
        "pass": true,
        "reasoning": "The c3-containers.md defines 4 containers: c3-0 (Web Application SPA with React), c3-1 (API Server with Node.js/Express), c3-2 (PostgreSQL Database), and c3-3 (Redis). This exceeds the minimum requirement of 3 containers."
      },
      {
        "text": "Real-time/WebSocket considerations are documented",
        "pass": true,
        "reasoning": "Real-time/WebSocket is extensively documented across multiple files: ADR-000 includes a 'Real-Time Architecture' section with Redis pub/sub diagram; c3-components.md defines the 'Realtime Module' (c3-1.8); and refs/websocket-handler.md provides detailed implementation patterns including Socket.IO setup, room management, presence tracking, and domain event integration."
      },
      {
        "text": "Component placeholders exist for key features (auth, tasks, teams)",
        "pass": true,
        "reasoning": "The c3-components.md defines comprehensive component placeholders: c3-1.1 (Auth Guard) for authentication, c3-1.7 (Task Module) for tasks, c3-1.5 (Workspace Module) for teams/workspaces, plus additional components for boards (c3-1.6), realtime (c3-1.8), and users (c3-1.9). Reference patterns also exist for auth-middleware, repository-pattern, etc."
      }
    ],
    "summary": "The C3 onboarding successfully created a comprehensive architectural design for TaskFlow SaaS. All required artifacts exist including ADR-000 as the blueprint, context documentation, 4 container definitions, detailed WebSocket/real-time considerations, and component placeholders for auth, tasks, teams and other key features."
  }
}